<!DOCTYPE html>
<!-- saved from url=(0050)https://zhuanlan.zhihu.com/p/22388833?refer=qyddai -->
<html lang="zh" data-theme="light" class=" no-touch" style="color: rgb(0, 0, 0); background-color: rgb(204, 232, 207);"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>android （MD）v7.widget.SearchView的使用解析。</title><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="google-site-verification" content="FTeR0c8arOPKh8c5DYh_9uu98_zJbaWw53J-Sch9MTg"><link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon"><link href="./android （MD）v7.widget.SearchView的使用解析。_files/app.373b5dbd1ff9ca3e42483cc8202a1267.css" rel="stylesheet"><script type="text/javascript" charset="utf-8" async="" src="./android （MD）v7.widget.SearchView的使用解析。_files/editor.74caf95642ff04785c7f.js"></script><style type="text/css">.Notification{position:fixed;top:0;left:50%;z-index:499;padding:14px 24px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-transform:translate(-50%);transform:translate(-50%);font-size:14px;color:#1a1a1a;pointer-events:all;border-radius:4px;-webkit-box-shadow:0 5px 20px rgba(26,26,26,.1);box-shadow:0 5px 20px rgba(26,26,26,.1);-webkit-box-sizing:border-box;box-sizing:border-box}@media (max-width:768px){.Notification{width:calc(100vw - 32px)}}@media (min-width:769px){.Notification{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:600px;min-width:520px}}html[data-theme=dark] .Notification{color:#999;-webkit-box-shadow:0 5px 20px rgba(0,0,0,.1);box-shadow:0 5px 20px rgba(0,0,0,.1)}.Notification-textSection{width:100%;display:inline-block}@media (max-width:768px){.Notification-textSection{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}}.Notification-textSection--withButton{text-align:left}.Notification-textSection--withoutButton{text-align:center}.Notification-actionsSection{white-space:nowrap;height:100%;margin:auto 0 auto 32px}.Notification-wrapper{position:fixed;top:0;right:0;bottom:0;left:0;z-index:503;overflow:hidden;pointer-events:none}.Notification-white{color:#1a1a1a;background:#fff}html[data-theme=dark] .Notification-white{color:#999;background:#1a1a1a}.Notification-red{color:#fff;background:#f1403c}html[data-theme=dark] .Notification-red{color:#1a1a1a;background:#b7302d}.Notification-red-ghost{color:#f1403c;background:#fff}html[data-theme=dark] .Notification-red-ghost{color:#b7302d;background:#1a1a1a}@-webkit-keyframes spring-in{0%{-webkit-transform:translate(-50%,-20px);transform:translate(-50%,-20px);opacity:.01}to{-webkit-transform:translate(-50%);transform:translate(-50%);opacity:1}}@keyframes spring-in{0%{-webkit-transform:translate(-50%,-20px);transform:translate(-50%,-20px);opacity:.01}to{-webkit-transform:translate(-50%);transform:translate(-50%);opacity:1}}@-webkit-keyframes spring-out{0%{-webkit-transform:translate(-50%);transform:translate(-50%);opacity:1}to{-webkit-transform:translate(-50%,-20px);transform:translate(-50%,-20px);opacity:0}}@keyframes spring-out{0%{-webkit-transform:translate(-50%);transform:translate(-50%);opacity:1}to{-webkit-transform:translate(-50%,-20px);transform:translate(-50%,-20px);opacity:0}}.Notification-enter{-webkit-animation:spring-in .3s;animation:spring-in .3s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.Notification-leave{-webkit-animation:spring-out .3s;animation:spring-out .3s;-webkit-animation-fill-mode:both;animation-fill-mode:both}</style><style type="text/css">.Formula{display:inline-block;vertical-align:middle;background:no-repeat 50%;background-size:contain;font-size:0}.Formula.isEditable{cursor:pointer}.Formula-image{max-width:100%;opacity:0;visibility:hidden}.Formula-placeholder{opacity:0}</style><style type="text/css">.MathToolbar{display:block;padding:4px 12px;border-radius:inherit inherit 0 0;background:#f6f6f6;border-bottom:1px solid #ebebeb;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html[data-theme=dark] .MathToolbar{background:#2e2e2e;border-bottom:1px solid #444}.MathToolbar-button{height:28px;padding:2px 4px;-webkit-box-sizing:border-box;box-sizing:border-box;border:1px solid transparent;vertical-align:middle}.MathToolbar-button+.MathToolbar-button{margin-left:16px}.MathToolbar-button:hover{background:#f6f6f6;border-color:#ebebeb}html[data-theme=dark] .MathToolbar-button:hover{background:#2e2e2e;border-color:#444}.MathToolbar-palettes{-ms-flex-wrap:wrap;flex-wrap:wrap;margin:-4px;padding:16px;max-width:384px}.MathToolbar-palettes,.MathToolbar-palettesButton{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.MathToolbar-palettesButton{margin:4px;padding:0;width:24px;height:24px;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:16px;color:#8590a6;border-radius:4px}.MathToolbar-palettesButton:hover{background-color:#f6f6f6}html[data-theme=dark] .MathToolbar-palettesButton:hover{background-color:#2e2e2e}html[data-theme=dark] .MathToolbar-palettesButton{color:#606a80}.MathToolbar-paletteIcon{max-width:calc(100% - 2px)}.MathToolbar-palettes--math{max-width:380px}.MathToolbar-palettes--math .MathToolbar-palettesButton{padding:0 3px;width:30px;height:60px}.MathToolbar-palettes--arrow .MathToolbar-palettesButton{height:35px}</style><style type="text/css">.FormulaModal{width:550px}.FormulaModal-input{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-bottom:30px}.FormulaModal-input .Input{padding:6px 12px;min-height:100px;-webkit-box-sizing:border-box;box-sizing:border-box}.FormulaModal-formula{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:0 3px;background:#fff;border:2px dashed #ebebeb;border-radius:3px;min-height:106px;overflow-x:auto}.FormulaModal-formula img{max-width:100%}html[data-theme=dark] .FormulaModal-formula{background:#1a1a1a;border:2px dashed #444}.FormulaModal-buttonGroup{margin-top:32px}.FormulaModal-previewText{color:#8590a6;font-size:14px}html[data-theme=dark] .FormulaModal-previewText{color:#606a80}</style><style type="text/css">.FocusPlugin--unfocused:hover{cursor:default;-webkit-box-shadow:0 0 0 2px rgba(0,132,255,.3);box-shadow:0 0 0 2px rgba(0,132,255,.3)}html[data-theme=dark] .FocusPlugin--unfocused:hover{-webkit-box-shadow:0 0 0 2px rgba(58,118,208,.3);box-shadow:0 0 0 2px rgba(58,118,208,.3)}.FocusPlugin--focused{cursor:default;-webkit-box-shadow:0 0 0 2px #0084ff;box-shadow:0 0 0 2px #0084ff}html[data-theme=dark] .FocusPlugin--focused{-webkit-box-shadow:0 0 0 2px #3a76d0;box-shadow:0 0 0 2px #3a76d0}</style><style type="text/css">.Image{max-width:100%;margin:0 auto}.Image[data-size=small]{max-width:40%}.Image--isBlock{display:block}</style><style type="text/css">.Editable-imageUploader{text-align:center}.Editable-imageUploader-layout{position:relative;display:inline-block;max-width:100%;vertical-align:top}.Editable-imageUploader-layout.is-fullWidth{width:100%}.Editable-imageUploader-image{display:block;max-width:100%;opacity:.3}.Editable-imageUploader-placeholder{height:192px;background-color:#ebebeb}html[data-theme=dark] .Editable-imageUploader-placeholder{background-color:#444}.Editable-imageUploader-status{position:absolute;left:0;top:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:100%}.Editable-imageUploader-statusText{font-size:28px;line-height:40px;color:#8590a6}html[data-theme=dark] .Editable-imageUploader-statusText{color:#606a80}.Editable-imageUploader-status.is-error .Editable-imageUploader-statusText{color:#f36}html[data-theme=dark] .Editable-imageUploader-status.is-error .Editable-imageUploader-statusText{color:#d92155}.Editable-imageUploader-retry{margin-top:4px;font-size:16px;line-height:32px}.Editable-imageUploader-retry .Button{font-size:inherit}.Editable-imageUploader-progress{position:absolute;left:0;bottom:0;width:100%;height:4px;background-color:#0084ff}.Editable-imageUploader-progress.is-error{background-color:#f36}html[data-theme=dark] .Editable-imageUploader-progress.is-error{background-color:#d92155}.Editable-imageUploader-progress .LoadingBar{position:relative;height:100%;background-color:hsla(0,0%,100%,.3)}html[data-theme=dark] .Editable-imageUploader-progress .LoadingBar{background-color:rgba(26,26,26,.3)}html[data-theme=dark] .Editable-imageUploader-progress{background-color:#3a76d0}</style><style type="text/css">.Image-caption.is-placeholder{color:#bfbfbf}html[data-theme=dark] .Image-caption.is-placeholder{color:gray}.Image-caption.is-editing{opacity:0}.Image-captionInput{position:absolute;z-index:203}.Image-captionInput textarea{display:block;overflow:hidden;width:100%;height:100%;padding:0;border:none;font:inherit;font-size:14px;line-height:1.5;text-align:center;color:#8590a6;background:none;resize:none}.Image-captionInput textarea::-webkit-input-placeholder{color:#bfbfbf}.Image-captionInput textarea:-ms-input-placeholder{color:#bfbfbf}.Image-captionInput textarea::placeholder{color:#bfbfbf}html[data-theme=dark] .Image-captionInput textarea::-webkit-input-placeholder{color:gray}html[data-theme=dark] .Image-captionInput textarea:-ms-input-placeholder{color:gray}html[data-theme=dark] .Image-captionInput textarea::placeholder{color:gray}.Image-captionInput textarea:focus{outline:none}html[data-theme=dark] .Image-captionInput textarea{color:#606a80}</style><style type="text/css">.Image-resizer{padding:8px}.Image-resizerButton{padding:0 8px;vertical-align:middle}.Image-resizerButton .Zi{display:block}.Image-resizerButton.is-active{color:#0084ff}html[data-theme=dark] .Image-resizerButton.is-active{color:#3a76d0}</style><style type="text/css">.Editable-video{margin:16px 0;border-radius:4px}.Video-uploadPosterButton{background:rgba(26,26,26,.5);border:1px solid hsla(0,0%,100%,.3);border-radius:3px;height:32px;width:109px;position:absolute;bottom:16px;right:16px;text-align:center;line-height:32px;cursor:pointer}.Video-uploadPosterButton p{color:#fff;font-size:14px;margin:0!important}html[data-theme=dark] .Video-uploadPosterButton p{color:#1a1a1a}html[data-theme=dark] .Video-uploadPosterButton{background:hsla(0,0%,60%,.5);border:1px solid rgba(26,26,26,.3)}</style><style type="text/css">.Editable-videoUploader{margin:16px 0;border-radius:4px}.Editable-videoUploader-thumbnail{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.Editable-videoUploader-text{text-align:center;position:relative;color:#8590a6}html[data-theme=dark] .Editable-videoUploader-text{color:#606a80}.Editable-videoUploader-status{font-size:28px;line-height:40px}.Editable-videoUploader-size{margin-top:10px;font-size:14px;line-height:20px}.Editable-videoUploader-progress{position:absolute;left:0;right:0;bottom:0;overflow:hidden;height:4px;background-color:rgba(26,26,26,.05)}html[data-theme=dark] .Editable-videoUploader-progress{background-color:hsla(0,0%,60%,.05)}.Editable-videoUploader-progress-bar{position:absolute;left:0;top:0;height:100%;background-color:#0084ff}.Editable-videoUploader-progress-bar.is-error{background-color:#f36}html[data-theme=dark] .Editable-videoUploader-progress-bar.is-error{background-color:#d92155}html[data-theme=dark] .Editable-videoUploader-progress-bar{background-color:#3a76d0}.Editable-videoUploader-progress .LoadingBar{position:absolute;left:0;top:0;height:100%;background-color:hsla(0,0%,100%,.3)}html[data-theme=dark] .Editable-videoUploader-progress .LoadingBar{background-color:rgba(26,26,26,.3)}.Editable-videoUploader-image{position:absolute}.Editable-videoUploader-uploadPosterButton{background:rgba(26,26,26,.5);border:1px solid hsla(0,0%,100%,.3);border-radius:3px;height:32px;width:109px;position:absolute;bottom:-130px;right:16px;text-align:center;line-height:32px;cursor:pointer}.Editable-videoUploader-uploadPosterButton p{color:#fff;font-size:14px;margin:0!important}html[data-theme=dark] .Editable-videoUploader-uploadPosterButton p{color:#1a1a1a}html[data-theme=dark] .Editable-videoUploader-uploadPosterButton{background:hsla(0,0%,60%,.5);border:1px solid rgba(26,26,26,.3)}.Editable-videoUploader-imageMask{width:100%;height:100%;position:absolute;background:hsla(0,0%,92%,.9)}html[data-theme=dark] .Editable-videoUploader-imageMask{background:rgba(68,68,68,.9)}</style><style type="text/css">.Editable-videoError{margin:16px 0;border-radius:4px}</style><style type="text/css">.Editable-divider{overflow:hidden}</style><style type="text/css">.Link+.Link{margin-left:2px}.Link[data-editable]{cursor:text!important}</style><style type="text/css">.LinkModal-input{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.LinkModal-input+.LinkModal-input{margin-top:10px}.LinkModal-input .Input{margin-left:8px}</style><style type="text/css">.LinkBubble.Popover-content--top.Popover-content--arrowed{margin-top:-10px}.LinkBubble.Popover-content--bottom.Popover-content--arrowed{margin-top:10px}.LinkBubble-content{display:block;padding:7px 10px 7px 16px}.LinkBubble-button,.LinkBubble-previewLink{vertical-align:middle}.LinkBubble-previewLink{display:inline-block;margin-right:8px;max-width:233px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-decoration:none;font-size:14px;line-height:1.3;border-bottom:1px solid transparent}.LinkBubble-previewLink:hover{color:#175199;border-bottom-color:rgba(0,132,255,.72)}html[data-theme=dark] .LinkBubble-previewLink:hover{color:#175199;border-bottom-color:rgba(58,118,208,.72)}.LinkBubble-button{padding:0 6px}</style><style type="text/css">.MentionSuggestions{position:absolute;z-index:203;line-height:1}.MentionSuggestions-input{width:200px;padding:4px 6px;font-size:inherit}.MentionSuggestions-input .Input{height:auto;background:transparent}.MentionSuggestions-menu{width:200px}.MentionSuggestions-menu .Menu-item{padding:0 10px}</style><style type="text/css">.Dropzone{position:relative}.Dropzone-cursor{position:absolute;left:0;right:0;margin:-1px 0;border-bottom:2px solid #0084ff;pointer-events:none}html[data-theme=dark] .Dropzone-cursor{border-bottom:2px solid #3a76d0}</style><style type="text/css">.Editable-toolbar{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;background:#fff;border-bottom:1px solid #ebebeb;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.isToolbarSticky .Editable-toolbar,.Sticky.is-fixed .Editable-toolbar{border-top:none!important;border-bottom:none!important}.isToolbarSticky .Editable-toolbar:after,.Sticky.is-fixed .Editable-toolbar:after{content:" ";position:absolute;left:0;top:100%;width:100%;pointer-events:none;height:3px;background:radial-gradient(ellipse at 50% 1%,rgba(26,26,26,.1),hsla(0,0%,100%,0) 80%)}html[data-theme=dark] .isToolbarSticky .Editable-toolbar:after,html[data-theme=dark] .Sticky.is-fixed .Editable-toolbar:after{background:radial-gradient(ellipse at 50% 1%,hsla(0,0%,60%,.1),rgba(26,26,26,0) 80%)}html[data-theme=dark] .Editable-toolbar{background:#1a1a1a;border-bottom:1px solid #444}.Editable-control,.Editable-toolbar-separator{margin-right:10px}.Editable-control:last-child,.Editable-toolbar-separator:last-child{margin-right:0}.Editable-toolbar-separator{display:inline-block;width:1px;height:28px;vertical-align:middle;background-color:#ebebeb}html[data-theme=dark] .Editable-toolbar-separator{background-color:#444}.Editable-control{padding:0 1px;height:28px;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box;white-space:nowrap;border:1px solid transparent}.Editable-control .Zi{fill:#8590a6}html[data-theme=dark] .Editable-control .Zi{fill:#606a80}.Editable-control:not(:disabled):hover{background:#f6f6f6;border-color:#ebebeb}html[data-theme=dark] .Editable-control:not(:disabled):hover{background:#2e2e2e;border-color:#444}.Editable-control.is-active .Zi{fill:#0084ff}html[data-theme=dark] .Editable-control.is-active .Zi{fill:#3a76d0}.Editable-control .Zi,.Editable-control span{vertical-align:middle}.Editable-control .Zi+span{margin-left:6px}</style><style type="text/css">.Editable-videoModal{display:block}.Editable-videoModal-typeButton{font-size:20px;font-weight:400;color:inherit}.Editable-videoModal-typeButton.is-active{font-weight:500;color:#0084ff}html[data-theme=dark] .Editable-videoModal-typeButton.is-active{color:#3a76d0}.Editable-videoModal-uploader{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-sizing:border-box;box-sizing:border-box;height:220px;border:2px dashed #ebebeb;border-radius:10px;cursor:pointer}.Editable-videoModal-uploader:hover{border-color:#8590a6}.Editable-videoModal-uploader:hover .Zi{fill:#8590a6}html[data-theme=dark] .Editable-videoModal-uploader:hover .Zi{fill:#606a80}html[data-theme=dark] .Editable-videoModal-uploader:hover{border-color:#606a80}.Editable-videoModal-uploader input{display:none}html[data-theme=dark] .Editable-videoModal-uploader{border:2px dashed #444}.Editable-videoModal-uploader-icon{text-align:center;display:block}.Editable-videoModal-uploader-icon .Zi{vertical-align:middle;fill:#ebebeb}html[data-theme=dark] .Editable-videoModal-uploader-icon .Zi{fill:#444}.Editable-videoModal-uploader-text{margin-top:10px;font-size:18px;line-height:30px;text-align:center}.Editable-videoModal-uploader-tip{font-size:14px;line-height:30px;text-align:center;color:#8590a6}html[data-theme=dark] .Editable-videoModal-uploader-tip{color:#606a80}</style><style type="text/css">.Editable-languageSuggestions{position:fixed;z-index:203}.Editable-languageSuggestionsInput{cursor:pointer}.Editable-languageSuggestionsInput input{cursor:inherit}.Editable-languageSuggestionsInput input:focus{cursor:text}.Editable-languageSuggestionsMenu{max-height:300px;margin-top:-8px;margin-bottom:-8px;overflow-y:auto}</style><style type="text/css">.Editable-notification-layout{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.Editable-notification-actions,.Editable-notification-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.Editable-notification-actions{margin:0 -12px}.Editable-notification-action{margin:0 12px}.Editable .RichText{cursor:text}.public-DraftEditorPlaceholder-root{position:absolute;pointer-events:none}.Editable--hidePlaceholder .public-DraftEditorPlaceholder-root{display:none}.Editable-styled,.Editable-unstyled{margin:0 0 .72em}.Editable-styled:last-child,.Editable-unstyled:last-child{margin-bottom:0}.DraftEditor-root blockquote+blockquote{margin-top:-1em}.DraftEditor-root pre.public-DraftStyleDefault-pre{border-radius:4px}.DraftEditor-root pre.public-DraftStyleDefault-pre pre{padding:0;margin:0;border-radius:0;overflow:visible;overflow:initial}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1,.DraftEditor-root .public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth1{margin-left:2em}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2,.DraftEditor-root .public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth2{margin-left:4em}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3,.DraftEditor-root .public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth3{margin-left:6em}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4,.DraftEditor-root .public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth4{margin-left:8em}.DraftEditor-root .public-DraftStyleDefault-orderedListItem{position:relative;list-style-type:none}.DraftEditor-root .public-DraftStyleDefault-orderedListItem:before{position:absolute;left:-36px;width:30px;text-align:right}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth0.public-DraftStyleDefault-reset{counter-reset:ol0}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth0:before{content:counter(ol0) ". ";counter-increment:ol0}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1.public-DraftStyleDefault-reset{counter-reset:ol1}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1:before{content:counter(ol1) ". ";counter-increment:ol1}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2.public-DraftStyleDefault-reset{counter-reset:ol2}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2:before{content:counter(ol2) ". ";counter-increment:ol2}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3.public-DraftStyleDefault-reset{counter-reset:ol3}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3:before{content:counter(ol3) ". ";counter-increment:ol3}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4.public-DraftStyleDefault-reset{counter-reset:ol4}.DraftEditor-root .public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4:before{content:counter(ol4) ". ";counter-increment:ol4}_:-ms-lang(x),pre.public-DraftStyleDefault-pre,pre.public-DraftStyleDefault-pre pre{overflow:visible;overflow:initial;word-wrap:break-word}</style><style type="text/css">.DraftEditor-root code[class*=language-],.DraftEditor-root pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}.DraftEditor-root code[class*=language-]::-moz-selection,.DraftEditor-root code[class*=language-] ::-moz-selection,.DraftEditor-root pre[class*=language-]::-moz-selection,.DraftEditor-root pre[class*=language-] ::-moz-selection{text-shadow:none;background:#bfbfbf}.DraftEditor-root code[class*=language-]::selection,.DraftEditor-root code[class*=language-] ::selection,.DraftEditor-root pre[class*=language-]::selection,.DraftEditor-root pre[class*=language-] ::selection{text-shadow:none;background:#bfbfbf}html[data-theme=dark] .DraftEditor-root code[class*=language-]::-moz-selection,html[data-theme=dark] .DraftEditor-root code[class*=language-] ::-moz-selection,html[data-theme=dark] .DraftEditor-root pre[class*=language-]::-moz-selection,html[data-theme=dark] .DraftEditor-root pre[class*=language-] ::-moz-selection{background:gray}html[data-theme=dark] .DraftEditor-root code[class*=language-]::selection,html[data-theme=dark] .DraftEditor-root code[class*=language-] ::selection,html[data-theme=dark] .DraftEditor-root pre[class*=language-]::selection,html[data-theme=dark] .DraftEditor-root pre[class*=language-] ::selection{background:gray}@media print{.DraftEditor-root code[class*=language-],.DraftEditor-root pre[class*=language-]{text-shadow:none}}.DraftEditor-root pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}.DraftEditor-root :not(pre)>code[class*=language-],.DraftEditor-root pre[class*=language-]{background:#f6f6f6}html[data-theme=dark] .DraftEditor-root :not(pre)>code[class*=language-],html[data-theme=dark] .DraftEditor-root pre[class*=language-]{background:#2e2e2e}.DraftEditor-root :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.DraftEditor-root .token.cdata,.DraftEditor-root .token.comment,.DraftEditor-root .token.doctype,.DraftEditor-root .token.prolog{color:#708090}.DraftEditor-root .token.punctuation{color:#999}html[data-theme=dark] .DraftEditor-root .token.punctuation{color:#646464}.DraftEditor-root .namespace{opacity:.7}.DraftEditor-root .token.boolean,.DraftEditor-root .token.constant,.DraftEditor-root .token.deleted,.DraftEditor-root .token.number,.DraftEditor-root .token.property,.DraftEditor-root .token.symbol,.DraftEditor-root .token.tag{color:#f36}html[data-theme=dark] .DraftEditor-root .token.boolean,html[data-theme=dark] .DraftEditor-root .token.constant,html[data-theme=dark] .DraftEditor-root .token.deleted,html[data-theme=dark] .DraftEditor-root .token.number,html[data-theme=dark] .DraftEditor-root .token.property,html[data-theme=dark] .DraftEditor-root .token.symbol,html[data-theme=dark] .DraftEditor-root .token.tag{color:#d92155}.DraftEditor-root .token.attr-name,.DraftEditor-root .token.builtin,.DraftEditor-root .token.char,.DraftEditor-root .token.inserted,.DraftEditor-root .token.selector,.DraftEditor-root .token.string,html[data-theme=dark] .DraftEditor-root .token.attr-name,html[data-theme=dark] .DraftEditor-root .token.builtin,html[data-theme=dark] .DraftEditor-root .token.char,html[data-theme=dark] .DraftEditor-root .token.inserted,html[data-theme=dark] .DraftEditor-root .token.selector,html[data-theme=dark] .DraftEditor-root .token.string{color:gray}.DraftEditor-root .language-css .token.string,.DraftEditor-root .style .token.string,.DraftEditor-root .token.entity,.DraftEditor-root .token.operator,.DraftEditor-root .token.url{color:#c2a469;background:hsla(0,0%,100%,.5)}html[data-theme=dark] .DraftEditor-root .language-css .token.string,html[data-theme=dark] .DraftEditor-root .style .token.string,html[data-theme=dark] .DraftEditor-root .token.entity,html[data-theme=dark] .DraftEditor-root .token.operator,html[data-theme=dark] .DraftEditor-root .token.url{color:#ba9b5d;background:rgba(26,26,26,.5)}.DraftEditor-root .token.atrule,.DraftEditor-root .token.attr-value,.DraftEditor-root .token.keyword{color:#0084ff}html[data-theme=dark] .DraftEditor-root .token.atrule,html[data-theme=dark] .DraftEditor-root .token.attr-value,html[data-theme=dark] .DraftEditor-root .token.keyword{color:#3a76d0}.DraftEditor-root .token.function{color:#f36}html[data-theme=dark] .DraftEditor-root .token.function{color:#d92155}.DraftEditor-root .token.important,.DraftEditor-root .token.regex,.DraftEditor-root .token.variable,html[data-theme=dark] .DraftEditor-root .token.important,html[data-theme=dark] .DraftEditor-root .token.regex,html[data-theme=dark] .DraftEditor-root .token.variable{color:#ff9607}.DraftEditor-root .token.bold,.DraftEditor-root .token.important{font-weight:600;font-synthesis:style}html[data-ios] .DraftEditor-root .token.bold,html[data-ios] .DraftEditor-root .token.important{font-weight:500}html[data-android] .DraftEditor-root .token.bold,html[data-android] .DraftEditor-root .token.important{font-weight:700}.DraftEditor-root .token.italic{font-style:italic}.DraftEditor-root .token.entity{cursor:help}</style></head><body style="color: rgb(0, 0, 0); background-color: rgb(204, 232, 207); zoom: 1;"><div id="react-root"><div data-reactroot=""><!-- react-empty: 2 --><div class="Layout av-cardBackground" data-zop-usertoken="{&quot;userToken&quot;:&quot;&quot;}"><!-- react-empty: 4 --><div class="Layout-navbarHolder"><header class="Navbar ScrollBackFixed ScrollBackFixed-animation"><div class="Navbar-logo-wrapper"><a class="Navbar-logo icon-ic_zhihu_logo" href="https://www.zhihu.com/" target="_blank" rel="noopener noreferrer" aria-label="知乎首页"></a></div><div class="Navbar-postTitle Navbar-title"><a href="https://zhuanlan.zhihu.com/qyddai"><img class="Navbar-columnIcon" alt="Android开发" src="./android （MD）v7.widget.SearchView的使用解析。_files/v2-28a7c692cda8c760ec9a242440d652ac_m.jpg"></a><div class="Navbar-postTitleName"><span class="Navbar-postTitleMeta">首发于</span><a class="Navbar-postTitleMain" href="https://zhuanlan.zhihu.com/qyddai">Android开发</a></div><!-- react-empty: 15 --></div><div class="Navbar-functionality"><a class="Navbar-write"><i class="icon icon-ic_nav_new"></i><!-- react-text: 19 -->写文章<!-- /react-text --></a><button class="Button Navbar-loginButon Button--blue" type="button"><!-- react-text: 21 -->登录<!-- /react-text --></button></div></header></div><!-- react-empty: 22 --><div></div><div class="Layout-main av-card av-paddingBottom av-bodyFont Layout-titleImage--normal"><div class="PostIndex-header av-paddingTop av-card" data-zop="{&quot;authorName&quot;:&quot;Bgwan&quot;,&quot;itemId&quot;:&quot;22388833&quot;,&quot;title&quot;:&quot;android （MD）v7.widget.SearchView的使用解析。&quot;,&quot;type&quot;:&quot;article&quot;}"><div class="TitleImage"><img alt="android （MD）v7.widget.SearchView的使用解析。" src="./android （MD）v7.widget.SearchView的使用解析。_files/b7153a2776958d2529f8429401e533ad_r.jpg" class="TitleImage-imagePure TitleImage-imagePure--fixed" height="431px"></div><h1 class="PostIndex-title av-paddingSide av-titleFont">android （MD）v7.widget.SearchView的使用解析。</h1><div class="PostIndex-author"><a href="https://www.zhihu.com/people/qydq" target="_blank" rel="noopener noreferrer"><img class="Avatar-hemingway PostIndex-authorAvatar Avatar--xs" alt="Bgwan" src="./android （MD）v7.widget.SearchView的使用解析。_files/464372bfcc3e304100f3cad266280fd5_xs.jpg" srcset="https://pic2.zhimg.com/464372bfcc3e304100f3cad266280fd5_l.jpg 2x"></a><a href="https://www.zhihu.com/people/qydq" target="_blank" class="PostIndex-authorName">Bgwan</a><!-- react-empty: 33 --><span class="Bull"></span><div class="HoverTitle" data-hover-title="2016 年 9月 10 日星期六上午 10 点 28 分"><time datetime="Sat Sep 10 2016 10:28:20 GMT+0800 (中国标准时间)">1 年前</time></div></div></div><div class="RichText PostIndex-content av-paddingSide av-card"><b>Begin</b><p>末尾附上SearchView的源代码。<br></p><p>SearchView是google在v7后面引入的一个搜索的控件，今天不是第一次使用这个控件了，很早之前实现SeachView的办法是自定义View，既然android官方网站已经给出了这个View我们就没有再去自定义SeachView了。</p><p>SearchView包含了很多新特性，在我的项目中很多的搜索功能都是通过SearchView来实现的，这次又要用到，所以写了这篇文章来吸粉。这个控件给我们封装了很多功能，也正因为这个，SearchView很多样式不好控制，比如输入框的背景图片，输入框的字体颜色等等！ 不过，<b>看过分析过源码的朋友</b>应该很容易实现这些功能，下面介绍如何使用SearchView。</p><p>第一步：定义menu.xml  ,或者是在layout中加入SearchView控件即可，如以下方式。</p><div class="highlight"><pre><code class="language-text"><span></span>&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context=".LauncherActivity"&gt;

    &lt;item
        android:id="@+id/search_contact"
        android:title="搜索"
        app:actionViewClass="android.support.v7.widget.SearchView"
        app:showAsAction="always" /&gt;
&lt;/menu&gt;
</code></pre></div><p>或者：（区别是一个是菜单一个是layout）</p><div class="highlight"><pre><code class="language-text"><span></span>&lt;android.support.v7.widget.SearchView
    android:id="@+id/searchView"
    android:layout_width="match_parent"
    android:layout_height="48dp"
    android:focusable="false"
    android:iconifiedByDefault="true"
    android:inputType="textFilter"
    android:queryHint="请输入您要查找的内容"
    android:textColor="#ABABAB"
    android:textColorHint="#ABABAB" /&gt;
</code></pre></div><p>第二步：获取SearchView控件，如下两种方式，</p><div class="highlight"><pre><code class="language-text"><span></span>searchView = (SearchView) findViewById(R.id.searchView);
listView = (ListView) findViewById(R.id.listView);
listView.setTextFilterEnabled(true);
</code></pre></div><p>或者：</p><div class="highlight"><pre><code class="language-text"><span></span>@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu_search, menu);
    final MenuItem item = menu.findItem(R.id.search_contact);
    mSearchView = (SearchView) MenuItemCompat.getActionView(item);
    return true;
}
</code></pre></div><p>获取到SearchView我们就可以设置相应的特征了，比如说，让SearchView一开始获得焦点我们可以使用如下属性。</p><div class="highlight"><pre><code class="language-text"><span></span>searchView.setIconified(false);
searchView.setQueryHint("请输入您要查找的内容");
</code></pre></div><p>或者用setQueryHint给出提示信息。如果不想它显示获得焦点可以使用下面的属性。</p><div class="highlight"><pre><code class="language-text"><span></span>mSearchView.setIconifiedByDefault(false);
</code></pre></div><p>第三步：设置SearchView的监听，点击事件。</p><p>onQueryTextSumit即是你提交搜索是调用的方法，然后onQueryTextchange是你输入框中的文本发生变化时调用的方法。代码如下面参考。</p><p>备注：这里使用了Snackbar的MD，有时间可能会解析这部分源代码。</p><div class="highlight"><pre><code class="language-text"><span></span>searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
@Override
    public boolean onQueryTextSubmit(String query) {
if (query.length() != 0) {
mSearchText = query;
            _loadData();

        } else {
listView.clearTextFilter();
            Snackbar.make(searchView, "搜索不能为空", Snackbar.LENGTH_LONG).setAction("Undo",
                    new View.OnClickListener() {
@Override
                        public void onClick(View v) {
                            Toast.makeText(getApplication(), "请输入内容后再试试", Toast.LENGTH_SHORT).show();
                        }
                    }).show();
        }

return false;
    }

@Override
    public boolean onQueryTextChange(String newText) {
if (newText.length() != 0) {
mSearchText = newText;
            listView.setFilterText(newText);

        } else {
listView.clearTextFilter();
        }
return false;
    }
});
</code></pre></div><p>第四步：以上就是简单实用SearchView的基本步骤，那么你是否存在疑问，如果我们要修改样式，比如说提示信息的文字的字体大小，还有，字体，背景颜色那应该如何处理呢。我在源码中找到这样如下的变量声明。</p><div class="highlight"><pre><code class="language-text"><span></span>private final SearchAutoComplete mSearchSrcTextView;
private final View mSearchEditFrame;
private final View mSearchPlate;
private final View mSubmitArea;
private final ImageView mSearchButton;
private final ImageView mGoButton;
private final ImageView mCloseButton;
private final ImageView mVoiceButton;
private final View mDropDownAnchor;
</code></pre></div><p>看到没有，SearchAutocomplete ，再继续源码追钟，发现该类是继承与EditText ，mSearchButton ,View 和这个类似，那么我自然知道如何修改Searchview的样式了。如下代码，找到SearchAutocompete，然后设置相应的属性即可。</p><div class="highlight"><pre><code class="language-text"><span></span>mEdit = (SearchView.SearchAutoComplete) searchView.findViewById(R.id.search_src_text);
mEdit.setTextSize(14);
</code></pre></div><p>其实这里还用了另外一种方法获取 id <br>closeImgId = context.getResources().getIdentifier(“search_close_btn”, “id”, getPackageName())<br>其实直接用 R.id.search_close_btn是一样的，没有区别！</p><p>我相信经过上面的分析，你已经能迅速并且完美的使用该新控件了，其实重要代码就是searchView.findViewById(R.id.search_src_text);</p><p>第五步：附上SearchView的源代码，你从这里可以直接查看（很多很多）。</p><p><b>*****<a href="http://link.zhihu.com/?target=http%3A//bgwan.blog.163.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">希望大家关注我的知乎，和个人github/qydq ，转载标明出处，谢谢。</a>*****</b><br></p><p>SearchView.java<br></p><div class="highlight"><pre><code class="language-text"><span></span>/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.support.v7.widget;

/**
 * A widget that provides a user interface for the user to enter a search query and submit a request
 * to a search provider. Shows a list of query suggestions or results, if available, and allows the
 * user to pick a suggestion or result to launch into.
 *
 * &lt;p class="note"&gt;&lt;strong&gt;Note:&lt;/strong&gt; This class is included in the &lt;a
 * href="{@docRoot}tools/extras/support-library.html"&gt;support library&lt;/a&gt; for compatibility
 * with API level 7 and higher. If you're developing your app for API level 11 and higher
 * &lt;em&gt;only&lt;/em&gt;, you should instead use the framework {@link android.widget.SearchView} class.&lt;/p&gt;
 *
 * &lt;p&gt;
 * When the SearchView is used in an {@link android.support.v7.app.ActionBar}
 * as an action view, it's collapsed by default, so you must provide an icon for the action.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If you want the search field to always be visible, then call
 * {@link #setIconifiedByDefault(boolean) setIconifiedByDefault(false)}.
 * &lt;/p&gt;
 *
 * &lt;div class="special reference"&gt;
 * &lt;h3&gt;Developer Guides&lt;/h3&gt;
 * &lt;p&gt;For information about using {@code SearchView}, read the
 * &lt;a href="{@docRoot}guide/topics/search/index.html"&gt;Search&lt;/a&gt; API guide.
 * Additional information about action views is also available in the &lt;&lt;a
 * href="{@docRoot}guide/topics/ui/actionbar.html#ActionView"&gt;Action Bar&lt;/a&gt; API guide&lt;/p&gt;
 * &lt;/div&gt;
 *
 * @see android.support.v4.view.MenuItemCompat#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
 */
public class SearchView extends LinearLayoutCompat implements CollapsibleActionView {

private static final boolean DBG = false;
    private static final String LOG_TAG = "SearchView";

    /**
     * Private constant for removing the microphone in the keyboard.
     */
    private static final String IME_OPTION_NO_MICROPHONE = "nm";

    private final SearchAutoComplete mSearchSrcTextView;
    private final View mSearchEditFrame;
    private final View mSearchPlate;
    private final View mSubmitArea;
    private final ImageView mSearchButton;
    private final ImageView mGoButton;
    private final ImageView mCloseButton;
    private final ImageView mVoiceButton;
    private final View mDropDownAnchor;

    private UpdatableTouchDelegate mTouchDelegate;
    private Rect mSearchSrcTextViewBounds = new Rect();
    private Rect mSearchSrtTextViewBoundsExpanded = new Rect();
    private int[] mTemp = new int[2];
    private int[] mTemp2 = new int[2];

    /** Icon optionally displayed when the SearchView is collapsed. */
    private final ImageView mCollapsedIcon;

    /** Drawable used as an EditText hint. */
    private final Drawable mSearchHintIcon;

    // Resources used by SuggestionsAdapter to display suggestions.
    private final int mSuggestionRowLayout;
    private final int mSuggestionCommitIconResId;

    // Intents used for voice searching.
    private final Intent mVoiceWebSearchIntent;
    private final Intent mVoiceAppSearchIntent;

    private final CharSequence mDefaultQueryHint;

    private OnQueryTextListener mOnQueryChangeListener;
    private OnCloseListener mOnCloseListener;
    private OnFocusChangeListener mOnQueryTextFocusChangeListener;
    private OnSuggestionListener mOnSuggestionListener;
    private OnClickListener mOnSearchClickListener;

    private boolean mIconifiedByDefault;
    private boolean mIconified;
    private CursorAdapter mSuggestionsAdapter;
    private boolean mSubmitButtonEnabled;
    private CharSequence mQueryHint;
    private boolean mQueryRefinement;
    private boolean mClearingFocus;
    private int mMaxWidth;
    private boolean mVoiceButtonEnabled;
    private CharSequence mOldQueryText;
    private CharSequence mUserQuery;
    private boolean mExpandedInActionView;
    private int mCollapsedImeOptions;

    private SearchableInfo mSearchable;
    private Bundle mAppSearchData;

    static final AutoCompleteTextViewReflector HIDDEN_METHOD_INVOKER = new AutoCompleteTextViewReflector();

    /*
     * SearchView can be set expanded before the IME is ready to be shown during
     * initial UI setup. The show operation is asynchronous to account for this.
     */
    private Runnable mShowImeRunnable = new Runnable() {
@Override
        public void run() {
            InputMethodManager imm = (InputMethodManager)
                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

            if (imm != null) {
HIDDEN_METHOD_INVOKER.showSoftInputUnchecked(imm, SearchView.this, 0);
            }
        }
    };

    private final Runnable mUpdateDrawableStateRunnable = new Runnable() {
@Override
        public void run() {
            updateFocusedState();
        }
    };

    private Runnable mReleaseCursorRunnable = new Runnable() {
@Override
        public void run() {
if (mSuggestionsAdapter != null &amp;&amp; mSuggestionsAdapter instanceof SuggestionsAdapter) {
mSuggestionsAdapter.changeCursor(null);
            }
        }
    };

    // A weak map of drawables we've gotten from other packages, so we don't load them
    // more than once.
    private final WeakHashMap&lt;String, Drawable.ConstantState&gt; mOutsideDrawablesCache =
new WeakHashMap&lt;String, Drawable.ConstantState&gt;();

    /**
     * Callbacks for changes to the query text.
     */
    public interface OnQueryTextListener {

/**
         * Called when the user submits the query. This could be due to a key press on the
         * keyboard or due to pressing a submit button.
         * The listener can override the standard behavior by returning true
         * to indicate that it has handled the submit request. Otherwise return false to
         * let the SearchView handle the submission by launching any associated intent.
         *
         * @param query the query text that is to be submitted
         *
         * @return true if the query has been handled by the listener, false to let the
         * SearchView perform the default action.
         */
        boolean onQueryTextSubmit(String query);

        /**
         * Called when the query text is changed by the user.
         *
         * @param newText the new content of the query text field.
         *
         * @return false if the SearchView should perform the default action of showing any
         * suggestions if available, true if the action was handled by the listener.
         */
        boolean onQueryTextChange(String newText);
    }

public interface OnCloseListener {

/**
         * The user is attempting to close the SearchView.
         *
         * @return true if the listener wants to override the default behavior of clearing the
         * text field and dismissing it, false otherwise.
         */
        boolean onClose();
    }

/**
     * Callback interface for selection events on suggestions. These callbacks
     * are only relevant when a SearchableInfo has been specified by {@link #setSearchableInfo}.
     */
    public interface OnSuggestionListener {

/**
         * Called when a suggestion was selected by navigating to it.
         * @param position the absolute position in the list of suggestions.
         *
         * @return true if the listener handles the event and wants to override the default
         * behavior of possibly rewriting the query based on the selected item, false otherwise.
         */
        boolean onSuggestionSelect(int position);

        /**
         * Called when a suggestion was clicked.
         * @param position the absolute position of the clicked item in the list of suggestions.
         *
         * @return true if the listener handles the event and wants to override the default
         * behavior of launching any intent or submitting a search query specified on that item.
         * Return false otherwise.
         */
        boolean onSuggestionClick(int position);
    }

public SearchView(Context context) {
this(context, null);
    }

public SearchView(Context context, AttributeSet attrs) {
this(context, attrs, R.attr.searchViewStyle);
    }

public SearchView(Context context, AttributeSet attrs, int defStyleAttr) {
super(context, attrs, defStyleAttr);

        final TintTypedArray a = TintTypedArray.obtainStyledAttributes(context,
                attrs, R.styleable.SearchView, defStyleAttr, 0);

        final LayoutInflater inflater = LayoutInflater.from(context);
        final int layoutResId = a.getResourceId(
                R.styleable.SearchView_layout, R.layout.abc_search_view);
        inflater.inflate(layoutResId, this, true);

        mSearchSrcTextView = (SearchAutoComplete) findViewById(R.id.search_src_text);
        mSearchSrcTextView.setSearchView(this);

        mSearchEditFrame = findViewById(R.id.search_edit_frame);
        mSearchPlate = findViewById(R.id.search_plate);
        mSubmitArea = findViewById(R.id.submit_area);
        mSearchButton = (ImageView) findViewById(R.id.search_button);
        mGoButton = (ImageView) findViewById(R.id.search_go_btn);
        mCloseButton = (ImageView) findViewById(R.id.search_close_btn);
        mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);
        mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);

        // Set up icons and backgrounds.
        mSearchPlate.setBackgroundDrawable(a.getDrawable(R.styleable.SearchView_queryBackground));
        mSubmitArea.setBackgroundDrawable(a.getDrawable(R.styleable.SearchView_submitBackground));
        mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));
        mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));
        mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));
        mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));
        mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));

        mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);

        // Extract dropdown layout resource IDs for later use.
        mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout,
                R.layout.abc_search_dropdown_item_icons_2line);
        mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);

        mSearchButton.setOnClickListener(mOnClickListener);
        mCloseButton.setOnClickListener(mOnClickListener);
        mGoButton.setOnClickListener(mOnClickListener);
        mVoiceButton.setOnClickListener(mOnClickListener);
        mSearchSrcTextView.setOnClickListener(mOnClickListener);

        mSearchSrcTextView.addTextChangedListener(mTextWatcher);
        mSearchSrcTextView.setOnEditorActionListener(mOnEditorActionListener);
        mSearchSrcTextView.setOnItemClickListener(mOnItemClickListener);
        mSearchSrcTextView.setOnItemSelectedListener(mOnItemSelectedListener);
        mSearchSrcTextView.setOnKeyListener(mTextKeyListener);

        // Inform any listener of focus changes
        mSearchSrcTextView.setOnFocusChangeListener(new OnFocusChangeListener() {
@Override
            public void onFocusChange(View v, boolean hasFocus) {
if (mOnQueryTextFocusChangeListener != null) {
mOnQueryTextFocusChangeListener.onFocusChange(SearchView.this, hasFocus);
                }
            }
        });
        setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));

        final int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);
        if (maxWidth != -1) {
            setMaxWidth(maxWidth);
        }

mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);
        mQueryHint = a.getText(R.styleable.SearchView_queryHint);

        final int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);
        if (imeOptions != -1) {
            setImeOptions(imeOptions);
        }

final int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);
        if (inputType != -1) {
            setInputType(inputType);
        }

boolean focusable = true;
        focusable = a.getBoolean(R.styleable.SearchView_android_focusable, focusable);
        setFocusable(focusable);

        a.recycle();

        // Save voice intent for later queries/launching
        mVoiceWebSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);

        mVoiceAppSearchIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        mDropDownAnchor = findViewById(mSearchSrcTextView.getDropDownAnchor());
        if (mDropDownAnchor != null) {
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
                addOnLayoutChangeListenerToDropDownAnchorSDK11();
            } else {
                addOnLayoutChangeListenerToDropDownAnchorBase();
            }
        }

        updateViewsVisibility(mIconifiedByDefault);
        updateQueryHint();
    }

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
private void addOnLayoutChangeListenerToDropDownAnchorSDK11() {
mDropDownAnchor.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
@Override
            public void onLayoutChange(View v, int left, int top, int right, int bottom,
                    int oldLeft, int oldTop, int oldRight, int oldBottom) {
                adjustDropDownSizeAndPosition();
            }
        });
    }

private void addOnLayoutChangeListenerToDropDownAnchorBase() {
mDropDownAnchor.getViewTreeObserver()
                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
@Override
                    public void onGlobalLayout() {
                        adjustDropDownSizeAndPosition();
                    }
                });
    }

int getSuggestionRowLayout() {
return mSuggestionRowLayout;
    }

int getSuggestionCommitIconResId() {
return mSuggestionCommitIconResId;
    }

/**
     * Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
     * to display labels, hints, suggestions, create intents for launching search results screens
     * and controlling other affordances such as a voice button.
     *
     * @param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific
     * activity or a global search provider.
     */
    public void setSearchableInfo(SearchableInfo searchable) {
mSearchable = searchable;
        if (mSearchable != null) {
            updateSearchAutoComplete();
            updateQueryHint();
        }
// Cache the voice search capability
        mVoiceButtonEnabled = hasVoiceSearch();

        if (mVoiceButtonEnabled) {
// Disable the microphone on the keyboard, as a mic is displayed near the text box
            // TODO: use imeOptions to disable voice input when the new API will be available
            mSearchSrcTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
        }
        updateViewsVisibility(isIconified());
    }

/**
     * Sets the APP_DATA for legacy SearchDialog use.
     * @param appSearchData bundle provided by the app when launching the search dialog
     * @hide
     */
    public void setAppSearchData(Bundle appSearchData) {
mAppSearchData = appSearchData;
    }

/**
     * Sets the IME options on the query text field.
     *
     * @see TextView#setImeOptions(int)
     * @param imeOptions the options to set on the query text field
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_imeOptions
     */
    public void setImeOptions(int imeOptions) {
mSearchSrcTextView.setImeOptions(imeOptions);
    }

/**
     * Returns the IME options set on the query text field.
     * @return the ime options
     * @see TextView#setImeOptions(int)
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_imeOptions
     */
    public int getImeOptions() {
return mSearchSrcTextView.getImeOptions();
    }

/**
     * Sets the input type on the query text field.
     *
     * @see TextView#setInputType(int)
     * @param inputType the input type to set on the query text field
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_inputType
     */
    public void setInputType(int inputType) {
mSearchSrcTextView.setInputType(inputType);
    }

/**
     * Returns the input type set on the query text field.
     * @return the input type
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_inputType
     */
    public int getInputType() {
return mSearchSrcTextView.getInputType();
    }

/** @hide */
    @Override
    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
// Don't accept focus if in the middle of clearing focus
        if (mClearingFocus) return false;
        // Check if SearchView is focusable.
        if (!isFocusable()) return false;
        // If it is not iconified, then give the focus to the text field
        if (!isIconified()) {
boolean result = mSearchSrcTextView.requestFocus(direction, previouslyFocusedRect);
            if (result) {
                updateViewsVisibility(false);
            }
return result;
        } else {
return super.requestFocus(direction, previouslyFocusedRect);
        }
    }

/** @hide */
    @Override
    public void clearFocus() {
mClearingFocus = true;
        setImeVisibility(false);
        super.clearFocus();
        mSearchSrcTextView.clearFocus();
        mClearingFocus = false;
    }

/**
     * Sets a listener for user actions within the SearchView.
     *
     * @param listener the listener object that receives callbacks when the user performs
     * actions in the SearchView such as clicking on buttons or typing a query.
     */
    public void setOnQueryTextListener(OnQueryTextListener listener) {
mOnQueryChangeListener = listener;
    }

/**
     * Sets a listener to inform when the user closes the SearchView.
     *
     * @param listener the listener to call when the user closes the SearchView.
     */
    public void setOnCloseListener(OnCloseListener listener) {
mOnCloseListener = listener;
    }

/**
     * Sets a listener to inform when the focus of the query text field changes.
     *
     * @param listener the listener to inform of focus changes.
     */
    public void setOnQueryTextFocusChangeListener(OnFocusChangeListener listener) {
mOnQueryTextFocusChangeListener = listener;
    }

/**
     * Sets a listener to inform when a suggestion is focused or clicked.
     *
     * @param listener the listener to inform of suggestion selection events.
     */
    public void setOnSuggestionListener(OnSuggestionListener listener) {
mOnSuggestionListener = listener;
    }

/**
     * Sets a listener to inform when the search button is pressed. This is only
     * relevant when the text field is not visible by default. Calling {@link #setIconified
     * setIconified(false)} can also cause this listener to be informed.
     *
     * @param listener the listener to inform when the search button is clicked or
     * the text field is programmatically de-iconified.
     */
    public void setOnSearchClickListener(OnClickListener listener) {
mOnSearchClickListener = listener;
    }

/**
     * Returns the query string currently in the text field.
     *
     * @return the query string
     */
    public CharSequence getQuery() {
return mSearchSrcTextView.getText();
    }

/**
     * Sets a query string in the text field and optionally submits the query as well.
     *
     * @param query the query string. This replaces any query text already present in the
     * text field.
     * @param submit whether to submit the query right now or only update the contents of
     * text field.
     */
    public void setQuery(CharSequence query, boolean submit) {
mSearchSrcTextView.setText(query);
        if (query != null) {
mSearchSrcTextView.setSelection(mSearchSrcTextView.length());
            mUserQuery = query;
        }

// If the query is not empty and submit is requested, submit the query
        if (submit &amp;&amp; !TextUtils.isEmpty(query)) {
            onSubmitQuery();
        }
    }

/**
     * Sets the hint text to display in the query text field. This overrides
     * any hint specified in the {@link SearchableInfo}.
     * &lt;p&gt;
     * This value may be specified as an empty string to prevent any query hint
     * from being displayed.
     *
     * @param hint the hint text to display or {@code null} to clear
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_queryHint
     */
    public void setQueryHint(@Nullable CharSequence hint) {
mQueryHint = hint;
        updateQueryHint();
    }

/**
     * Returns the hint text that will be displayed in the query text field.
     * &lt;p&gt;
     * The displayed query hint is chosen in the following order:
     * &lt;ol&gt;
     * &lt;li&gt;Non-null value set with {@link #setQueryHint(CharSequence)}
     * &lt;li&gt;Value specified in XML using {@code app:queryHint}
     * &lt;li&gt;Valid string resource ID exposed by the {@link SearchableInfo} via
     *     {@link SearchableInfo#getHintId()}
     * &lt;li&gt;Default hint provided by the theme against which the view was
     *     inflated
     * &lt;/ol&gt;
     *
     *
     *
     * @return the displayed query hint text, or {@code null} if none set
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_queryHint
     */
    @Nullable
    public CharSequence getQueryHint() {
final CharSequence hint;
        if (mQueryHint != null) {
            hint = mQueryHint;
        } else if (mSearchable != null &amp;&amp; mSearchable.getHintId() != 0) {
            hint = getContext().getText(mSearchable.getHintId());
        } else {
            hint = mDefaultQueryHint;
        }
return hint;
    }

/**
     * Sets the default or resting state of the search field. If true, a single search icon is
     * shown by default and expands to show the text field and other buttons when pressed. Also,
     * if the default state is iconified, then it collapses to that state when the close button
     * is pressed. Changes to this property will take effect immediately.
     *
     * &lt;p&gt;The default value is true.&lt;/p&gt;
     *
     * @param iconified whether the search field should be iconified by default
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_iconifiedByDefault
     */
    public void setIconifiedByDefault(boolean iconified) {
if (mIconifiedByDefault == iconified) return;
        mIconifiedByDefault = iconified;
        updateViewsVisibility(iconified);
        updateQueryHint();
    }

/**
     * Returns the default iconified state of the search field.
     * @return
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_iconifiedByDefault
     */
    public boolean isIconfiedByDefault() {
return mIconifiedByDefault;
    }

/**
     * Iconifies or expands the SearchView. Any query text is cleared when iconified. This is
     * a temporary state and does not override the default iconified state set by
     * {@link #setIconifiedByDefault(boolean)}. If the default state is iconified, then
     * a false here will only be valid until the user closes the field. And if the default
     * state is expanded, then a true here will only clear the text field and not close it.
     *
     * @param iconify a true value will collapse the SearchView to an icon, while a false will
     * expand it.
     */
    public void setIconified(boolean iconify) {
if (iconify) {
            onCloseClicked();
        } else {
            onSearchClicked();
        }
    }

/**
     * Returns the current iconified state of the SearchView.
     *
     * @return true if the SearchView is currently iconified, false if the search field is
     * fully visible.
     */
    public boolean isIconified() {
return mIconified;
    }

/**
     * Enables showing a submit button when the query is non-empty. In cases where the SearchView
     * is being used to filter the contents of the current activity and doesn't launch a separate
     * results activity, then the submit button should be disabled.
     *
     * @param enabled true to show a submit button for submitting queries, false if a submit
     * button is not required.
     */
    public void setSubmitButtonEnabled(boolean enabled) {
mSubmitButtonEnabled = enabled;
        updateViewsVisibility(isIconified());
    }

/**
     * Returns whether the submit button is enabled when necessary or never displayed.
     *
     * @return whether the submit button is enabled automatically when necessary
     */
    public boolean isSubmitButtonEnabled() {
return mSubmitButtonEnabled;
    }

/**
     * Specifies if a query refinement button should be displayed alongside each suggestion
     * or if it should depend on the flags set in the individual items retrieved from the
     * suggestions provider. Clicking on the query refinement button will replace the text
     * in the query text field with the text from the suggestion. This flag only takes effect
     * if a SearchableInfo has been specified with {@link #setSearchableInfo(SearchableInfo)}
     * and not when using a custom adapter.
     *
     * @param enable true if all items should have a query refinement button, false if only
     * those items that have a query refinement flag set should have the button.
     *
     * @see SearchManager#SUGGEST_COLUMN_FLAGS
     * @see SearchManager#FLAG_QUERY_REFINEMENT
     */
    public void setQueryRefinementEnabled(boolean enable) {
mQueryRefinement = enable;
        if (mSuggestionsAdapter instanceof SuggestionsAdapter) {
            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(
                    enable ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
        }
    }

/**
     * Returns whether query refinement is enabled for all items or only specific ones.
     * @return true if enabled for all items, false otherwise.
     */
    public boolean isQueryRefinementEnabled() {
return mQueryRefinement;
    }

/**
     * You can set a custom adapter if you wish. Otherwise the default adapter is used to
     * display the suggestions from the suggestions provider associated with the SearchableInfo.
     *
     * @see #setSearchableInfo(SearchableInfo)
     */
    public void setSuggestionsAdapter(CursorAdapter adapter) {
mSuggestionsAdapter = adapter;

        mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
    }

/**
     * Returns the adapter used for suggestions, if any.
     * @return the suggestions adapter
     */
    public CursorAdapter getSuggestionsAdapter() {
return mSuggestionsAdapter;
    }

/**
     * Makes the view at most this many pixels wide
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_maxWidth
     */
    public void setMaxWidth(int maxpixels) {
mMaxWidth = maxpixels;

        requestLayout();
    }

/**
     * Gets the specified maximum width in pixels, if set. Returns zero if
     * no maximum width was specified.
     * @return the maximum width of the view
     *
     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_maxWidth
     */
    public int getMaxWidth() {
return mMaxWidth;
    }

@Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
// Let the standard measurements take effect in iconified state.
        if (isIconified()) {
super.onMeasure(widthMeasureSpec, heightMeasureSpec);
            return;
        }

int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int width = MeasureSpec.getSize(widthMeasureSpec);

        switch (widthMode) {
case MeasureSpec.AT_MOST:
// If there is an upper limit, don't exceed maximum width (explicit or implicit)
                if (mMaxWidth &gt; 0) {
                    width = Math.min(mMaxWidth, width);
                } else {
                    width = Math.min(getPreferredWidth(), width);
                }
break;
            case MeasureSpec.EXACTLY:
// If an exact width is specified, still don't exceed any specified maximum width
                if (mMaxWidth &gt; 0) {
                    width = Math.min(mMaxWidth, width);
                }
break;
            case MeasureSpec.UNSPECIFIED:
// Use maximum width, if specified, else preferred width
                width = mMaxWidth &gt; 0 ? mMaxWidth : getPreferredWidth();
                break;
        }
        widthMode = MeasureSpec.EXACTLY;

        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int height = MeasureSpec.getSize(heightMeasureSpec);

        switch (heightMode) {
case MeasureSpec.AT_MOST:
case MeasureSpec.UNSPECIFIED:
                height = Math.min(getPreferredHeight(), height);
                break;
        }
        heightMode = MeasureSpec.EXACTLY;

        super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode),
                MeasureSpec.makeMeasureSpec(height, heightMode));
    }

@Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
super.onLayout(changed, left, top, right, bottom);

        if (changed) {
// Expand mSearchSrcTextView touch target to be the height of the parent in order to
            // allow it to be up to 48dp.
            getChildBoundsWithinSearchView(mSearchSrcTextView, mSearchSrcTextViewBounds);
            mSearchSrtTextViewBoundsExpanded.set(
mSearchSrcTextViewBounds.left, 0, mSearchSrcTextViewBounds.right, bottom - top);
            if (mTouchDelegate == null) {
mTouchDelegate = new UpdatableTouchDelegate(mSearchSrtTextViewBoundsExpanded,
                        mSearchSrcTextViewBounds, mSearchSrcTextView);
                setTouchDelegate(mTouchDelegate);
            } else {
mTouchDelegate.setBounds(mSearchSrtTextViewBoundsExpanded, mSearchSrcTextViewBounds);
            }
        }
    }

private void getChildBoundsWithinSearchView(View view, Rect rect) {
        view.getLocationInWindow(mTemp);
        getLocationInWindow(mTemp2);
        final int top = mTemp[1] - mTemp2[1];
        final int left = mTemp[0] - mTemp2[0];
        rect.set(left, top, left + view.getWidth(), top + view.getHeight());
    }

private int getPreferredWidth() {
return getContext().getResources()
                .getDimensionPixelSize(R.dimen.abc_search_view_preferred_width);
    }

private int getPreferredHeight() {
return getContext().getResources()
                .getDimensionPixelSize(R.dimen.abc_search_view_preferred_height);
    }

private void updateViewsVisibility(final boolean collapsed) {
mIconified = collapsed;
        // Visibility of views that are visible when collapsed
        final int visCollapsed = collapsed ? VISIBLE : GONE;
        // Is there text in the query
        final boolean hasText = !TextUtils.isEmpty(mSearchSrcTextView.getText());

        mSearchButton.setVisibility(visCollapsed);
        updateSubmitButton(hasText);
        mSearchEditFrame.setVisibility(collapsed ? GONE : VISIBLE);

        final int iconVisibility;
        if (mCollapsedIcon.getDrawable() == null || mIconifiedByDefault) {
            iconVisibility = GONE;
        } else {
            iconVisibility = VISIBLE;
        }
mCollapsedIcon.setVisibility(iconVisibility);

        updateCloseButton();
        updateVoiceButton(!hasText);
        updateSubmitArea();
    }

private boolean hasVoiceSearch() {
if (mSearchable != null &amp;&amp; mSearchable.getVoiceSearchEnabled()) {
            Intent testIntent = null;
            if (mSearchable.getVoiceSearchLaunchWebSearch()) {
                testIntent = mVoiceWebSearchIntent;
            } else if (mSearchable.getVoiceSearchLaunchRecognizer()) {
                testIntent = mVoiceAppSearchIntent;
            }
if (testIntent != null) {
                ResolveInfo ri = getContext().getPackageManager().resolveActivity(testIntent,
                        PackageManager.MATCH_DEFAULT_ONLY);
                return ri != null;
            }
        }
return false;
    }

private boolean isSubmitAreaEnabled() {
return (mSubmitButtonEnabled || mVoiceButtonEnabled) &amp;&amp; !isIconified();
    }

private void updateSubmitButton(boolean hasText) {
int visibility = GONE;
        if (mSubmitButtonEnabled &amp;&amp; isSubmitAreaEnabled() &amp;&amp; hasFocus()
                &amp;&amp; (hasText || !mVoiceButtonEnabled)) {
            visibility = VISIBLE;
        }
mGoButton.setVisibility(visibility);
    }

private void updateSubmitArea() {
int visibility = GONE;
        if (isSubmitAreaEnabled()
                &amp;&amp; (mGoButton.getVisibility() == VISIBLE
                        || mVoiceButton.getVisibility() == VISIBLE)) {
            visibility = VISIBLE;
        }
mSubmitArea.setVisibility(visibility);
    }

private void updateCloseButton() {
final boolean hasText = !TextUtils.isEmpty(mSearchSrcTextView.getText());
        // Should we show the close button? It is not shown if there's no focus,
        // field is not iconified by default and there is no text in it.
        final boolean showClose = hasText || (mIconifiedByDefault &amp;&amp; !mExpandedInActionView);
        mCloseButton.setVisibility(showClose ? VISIBLE : GONE);
        final Drawable closeButtonImg = mCloseButton.getDrawable();
        if (closeButtonImg != null){
            closeButtonImg.setState(hasText ? ENABLED_STATE_SET : EMPTY_STATE_SET);
        }
    }

private void postUpdateFocusedState() {
        post(mUpdateDrawableStateRunnable);
    }

private void updateFocusedState() {
final boolean focused = mSearchSrcTextView.hasFocus();
        final int[] stateSet = focused ? FOCUSED_STATE_SET : EMPTY_STATE_SET;
        final Drawable searchPlateBg = mSearchPlate.getBackground();
        if (searchPlateBg != null) {
            searchPlateBg.setState(stateSet);
        }
final Drawable submitAreaBg = mSubmitArea.getBackground();
        if (submitAreaBg != null) {
            submitAreaBg.setState(stateSet);
        }
        invalidate();
    }

@Override
    protected void onDetachedFromWindow() {
        removeCallbacks(mUpdateDrawableStateRunnable);
        post(mReleaseCursorRunnable);
        super.onDetachedFromWindow();
    }

private void setImeVisibility(final boolean visible) {
if (visible) {
            post(mShowImeRunnable);
        } else {
            removeCallbacks(mShowImeRunnable);
            InputMethodManager imm = (InputMethodManager)
                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

            if (imm != null) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
        }
    }

/**
     * Called by the SuggestionsAdapter
     * @hide
     */
    /* package */void onQueryRefine(CharSequence queryText) {
        setQuery(queryText);
    }

private final OnClickListener mOnClickListener = new OnClickListener() {
@Override
        public void onClick(View v) {
if (v == mSearchButton) {
                onSearchClicked();
            } else if (v == mCloseButton) {
                onCloseClicked();
            } else if (v == mGoButton) {
                onSubmitQuery();
            } else if (v == mVoiceButton) {
                onVoiceClicked();
            } else if (v == mSearchSrcTextView) {
                forceSuggestionQuery();
            }
        }
    };

    /**
     * React to the user typing "enter" or other hardwired keys while typing in
     * the search box. This handles these special keys while the edit box has
     * focus.
     */
    View.OnKeyListener mTextKeyListener = new View.OnKeyListener() {
@Override
        public boolean onKey(View v, int keyCode, KeyEvent event) {
// guard against possible race conditions
            if (mSearchable == null) {
return false;
            }

if (DBG) {
                Log.d(LOG_TAG, "mTextListener.onKey(" + keyCode + "," + event + "), selection: "
                        + mSearchSrcTextView.getListSelection());
            }

// If a suggestion is selected, handle enter, search key, and action keys
            // as presses on the selected suggestion
            if (mSearchSrcTextView.isPopupShowing()
                    &amp;&amp; mSearchSrcTextView.getListSelection() != ListView.INVALID_POSITION) {
return onSuggestionsKey(v, keyCode, event);
            }

// If there is text in the query box, handle enter, and action keys
            // The search key is handled by the dialog's onKeyDown().
            if (!mSearchSrcTextView.isEmpty() &amp;&amp; KeyEventCompat.hasNoModifiers(event)) {
if (event.getAction() == KeyEvent.ACTION_UP) {
if (keyCode == KeyEvent.KEYCODE_ENTER) {
                        v.cancelLongPress();

                        // Launch as a regular search.
                        launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, mSearchSrcTextView.getText()
                                .toString());
                        return true;
                    }
                }
            }
return false;
        }
    };

    /**
     * React to the user typing while in the suggestions list. First, check for
     * action keys. If not handled, try refocusing regular characters into the
     * EditText.
     */
    private boolean onSuggestionsKey(View v, int keyCode, KeyEvent event) {
// guard against possible race conditions (late arrival after dismiss)
        if (mSearchable == null) {
return false;
        }
if (mSuggestionsAdapter == null) {
return false;
        }
if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; KeyEventCompat.hasNoModifiers(event)) {
// First, check for enter or search (both of which we'll treat as a
            // "click")
            if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH
                    || keyCode == KeyEvent.KEYCODE_TAB) {
int position = mSearchSrcTextView.getListSelection();
                return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
            }

// Next, check for left/right moves, which we use to "return" the
            // user to the edit view
            if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
// give "focus" to text editor, with cursor at the beginning if
                // left key, at end if right key
                // TODO: Reverse left/right for right-to-left languages, e.g.
                // Arabic
                int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mSearchSrcTextView
                        .length();
                mSearchSrcTextView.setSelection(selPoint);
                mSearchSrcTextView.setListSelection(0);
                mSearchSrcTextView.clearListSelection();
                HIDDEN_METHOD_INVOKER.ensureImeVisible(mSearchSrcTextView, true);

                return true;
            }

// Next, check for an "up and out" move
            if (keyCode == KeyEvent.KEYCODE_DPAD_UP &amp;&amp; 0 == mSearchSrcTextView.getListSelection()) {
// TODO: restoreUserQuery();
                // let ACTV complete the move
                return false;
            }
        }
return false;
    }

private CharSequence getDecoratedHint(CharSequence hintText) {
// If the field is always expanded or we don't have a search hint icon,
        // then don't add the search icon to the hint.
        if (!mIconifiedByDefault || mSearchHintIcon == null) {
return hintText;
        }

final int textSize = (int) (mSearchSrcTextView.getTextSize() * 1.25);
        mSearchHintIcon.setBounds(0, 0, textSize, textSize);

        final SpannableStringBuilder ssb = new SpannableStringBuilder("   ");
        ssb.setSpan(new ImageSpan(mSearchHintIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        ssb.append(hintText);
        return ssb;
    }

private void updateQueryHint() {
final CharSequence hint = getQueryHint();
        mSearchSrcTextView.setHint(getDecoratedHint(hint == null ? "" : hint));
    }

/**
     * Updates the auto-complete text view.
     */
    private void updateSearchAutoComplete() {
mSearchSrcTextView.setThreshold(mSearchable.getSuggestThreshold());
        mSearchSrcTextView.setImeOptions(mSearchable.getImeOptions());
        int inputType = mSearchable.getInputType();
        // We only touch this if the input type is set up for text (which it almost certainly
        // should be, in the case of search!)
        if ((inputType &amp; InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
// The existence of a suggestions authority is the proxy for "suggestions
            // are available here"
            inputType &amp;= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
            if (mSearchable.getSuggestAuthority() != null) {
                inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
                // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
                // auto-completion based on its own semantics, which it will present to the user
                // as they type. This generally means that the input method should not show its
                // own candidates, and the spell checker should not be in action. The text editor
                // supplies its candidates by calling InputMethodManager.displayCompletions(),
                // which in turn will call InputMethodSession.displayCompletions().
                inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
            }
        }
mSearchSrcTextView.setInputType(inputType);
        if (mSuggestionsAdapter != null) {
mSuggestionsAdapter.changeCursor(null);
        }
// attach the suggestions adapter, if suggestions are available
        // The existence of a suggestions authority is the proxy for "suggestions available here"
        if (mSearchable.getSuggestAuthority() != null) {
mSuggestionsAdapter = new SuggestionsAdapter(getContext(),
                    this, mSearchable, mOutsideDrawablesCache);
            mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(
mQueryRefinement ? SuggestionsAdapter.REFINE_ALL
                    : SuggestionsAdapter.REFINE_BY_ENTRY);
        }
    }

/**
     * Update the visibility of the voice button.  There are actually two voice search modes,
     * either of which will activate the button.
     * @param empty whether the search query text field is empty. If it is, then the other
     * criteria apply to make the voice button visible.
     */
    private void updateVoiceButton(boolean empty) {
int visibility = GONE;
        if (mVoiceButtonEnabled &amp;&amp; !isIconified() &amp;&amp; empty) {
            visibility = VISIBLE;
            mGoButton.setVisibility(GONE);
        }
mVoiceButton.setVisibility(visibility);
    }

private final OnEditorActionListener mOnEditorActionListener = new OnEditorActionListener() {

/**
         * Called when the input method default action key is pressed.
         */
        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            onSubmitQuery();
            return true;
        }
    };

    private void onTextChanged(CharSequence newText) {
        CharSequence text = mSearchSrcTextView.getText();
        mUserQuery = text;
        boolean hasText = !TextUtils.isEmpty(text);
        updateSubmitButton(hasText);
        updateVoiceButton(!hasText);
        updateCloseButton();
        updateSubmitArea();
        if (mOnQueryChangeListener != null &amp;&amp; !TextUtils.equals(newText, mOldQueryText)) {
mOnQueryChangeListener.onQueryTextChange(newText.toString());
        }
mOldQueryText = newText.toString();
    }

private void onSubmitQuery() {
        CharSequence query = mSearchSrcTextView.getText();
        if (query != null &amp;&amp; TextUtils.getTrimmedLength(query) &gt; 0) {
if (mOnQueryChangeListener == null
                    || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) {
if (mSearchable != null) {
                    launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString());
                }
                setImeVisibility(false);
                dismissSuggestions();
            }
        }
    }

private void dismissSuggestions() {
mSearchSrcTextView.dismissDropDown();
    }

private void onCloseClicked() {
        CharSequence text = mSearchSrcTextView.getText();
        if (TextUtils.isEmpty(text)) {
if (mIconifiedByDefault) {
// If the app doesn't override the close behavior
                if (mOnCloseListener == null || !mOnCloseListener.onClose()) {
// hide the keyboard and remove focus
                    clearFocus();
                    // collapse the search field
                    updateViewsVisibility(true);
                }
            }
        } else {
mSearchSrcTextView.setText("");
            mSearchSrcTextView.requestFocus();
            setImeVisibility(true);
        }

    }

private void onSearchClicked() {
        updateViewsVisibility(false);
        mSearchSrcTextView.requestFocus();
        setImeVisibility(true);
        if (mOnSearchClickListener != null) {
mOnSearchClickListener.onClick(this);
        }
    }

private void onVoiceClicked() {
// guard against possible race conditions
        if (mSearchable == null) {
return;
        }
        SearchableInfo searchable = mSearchable;
        try {
if (searchable.getVoiceSearchLaunchWebSearch()) {
                Intent webSearchIntent = createVoiceWebSearchIntent(mVoiceWebSearchIntent,
                        searchable);
                getContext().startActivity(webSearchIntent);
            } else if (searchable.getVoiceSearchLaunchRecognizer()) {
                Intent appSearchIntent = createVoiceAppSearchIntent(mVoiceAppSearchIntent,
                        searchable);
                getContext().startActivity(appSearchIntent);
            }
        } catch (ActivityNotFoundException e) {
// Should not happen, since we check the availability of
            // voice search before showing the button. But just in case...
            Log.w(LOG_TAG, "Could not find voice search activity");
        }
    }

void onTextFocusChanged() {
        updateViewsVisibility(isIconified());
        // Delayed update to make sure that the focus has settled down and window focus changes
        // don't affect it. A synchronous update was not working.
        postUpdateFocusedState();
        if (mSearchSrcTextView.hasFocus()) {
            forceSuggestionQuery();
        }
    }

@Override
    public void onWindowFocusChanged(boolean hasWindowFocus) {
super.onWindowFocusChanged(hasWindowFocus);

        postUpdateFocusedState();
    }

/**
     * {@inheritDoc}
     */
    @Override
    public void onActionViewCollapsed() {
        setQuery("", false);
        clearFocus();
        updateViewsVisibility(true);
        mSearchSrcTextView.setImeOptions(mCollapsedImeOptions);
        mExpandedInActionView = false;
    }

/**
     * {@inheritDoc}
     */
    @Override
    public void onActionViewExpanded() {
if (mExpandedInActionView) return;

        mExpandedInActionView = true;
        mCollapsedImeOptions = mSearchSrcTextView.getImeOptions();
        mSearchSrcTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
        mSearchSrcTextView.setText("");
        setIconified(false);
    }

static class SavedState extends AbsSavedState {
boolean isIconified;

        SavedState(Parcelable superState) {
super(superState);
        }

public SavedState(Parcel source, ClassLoader loader) {
super(source, loader);
            isIconified = (Boolean) source.readValue(null);
        }

@Override
        public void writeToParcel(Parcel dest, int flags) {
super.writeToParcel(dest, flags);
            dest.writeValue(isIconified);
        }

@Override
        public String toString() {
return "SearchView.SavedState{"
                    + Integer.toHexString(System.identityHashCode(this))
                    + " isIconified=" + isIconified + "}";
        }

public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = ParcelableCompat.newCreator(
new ParcelableCompatCreatorCallbacks&lt;SavedState&gt;() {
@Override
                    public SavedState createFromParcel(Parcel in, ClassLoader loader) {
return new SavedState(in, loader);
                    }

@Override
                    public SavedState[] newArray(int size) {
return new SavedState[size];
                    }
                });
    }

@Override
    protected Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState ss = new SavedState(superState);
        ss.isIconified = isIconified();
        return ss;
    }

@Override
    protected void onRestoreInstanceState(Parcelable state) {
if (!(state instanceof SavedState)) {
super.onRestoreInstanceState(state);
            return;
        }
        SavedState ss = (SavedState) state;
        super.onRestoreInstanceState(ss.getSuperState());
        updateViewsVisibility(ss.isIconified);
        requestLayout();
    }

private void adjustDropDownSizeAndPosition() {
if (mDropDownAnchor.getWidth() &gt; 1) {
            Resources res = getContext().getResources();
            int anchorPadding = mSearchPlate.getPaddingLeft();
            Rect dropDownPadding = new Rect();
            final boolean isLayoutRtl = ViewUtils.isLayoutRtl(this);
            int iconOffset = mIconifiedByDefault
                    ? res.getDimensionPixelSize(R.dimen.abc_dropdownitem_icon_width)
                    + res.getDimensionPixelSize(R.dimen.abc_dropdownitem_text_padding_left)
                    : 0;
            mSearchSrcTextView.getDropDownBackground().getPadding(dropDownPadding);
            int offset;
            if (isLayoutRtl) {
                offset = - dropDownPadding.left;
            } else {
                offset = anchorPadding - (dropDownPadding.left + iconOffset);
            }
mSearchSrcTextView.setDropDownHorizontalOffset(offset);
            final int width = mDropDownAnchor.getWidth() + dropDownPadding.left
                    + dropDownPadding.right + iconOffset - anchorPadding;
            mSearchSrcTextView.setDropDownWidth(width);
        }
    }

private boolean onItemClicked(int position, int actionKey, String actionMsg) {
if (mOnSuggestionListener == null
                || !mOnSuggestionListener.onSuggestionClick(position)) {
            launchSuggestion(position, KeyEvent.KEYCODE_UNKNOWN, null);
            setImeVisibility(false);
            dismissSuggestions();
            return true;
        }
return false;
    }

private boolean onItemSelected(int position) {
if (mOnSuggestionListener == null
                || !mOnSuggestionListener.onSuggestionSelect(position)) {
            rewriteQueryFromSuggestion(position);
            return true;
        }
return false;
    }

private final OnItemClickListener mOnItemClickListener = new OnItemClickListener() {

/**
         * Implements OnItemClickListener
         */
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
if (DBG) Log.d(LOG_TAG, "onItemClick() position " + position);
            onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
        }
    };

    private final OnItemSelectedListener mOnItemSelectedListener = new OnItemSelectedListener() {

/**
         * Implements OnItemSelectedListener
         */
        @Override
        public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
if (DBG) Log.d(LOG_TAG, "onItemSelected() position " + position);
            SearchView.this.onItemSelected(position);
        }

/**
         * Implements OnItemSelectedListener
         */
        @Override
        public void onNothingSelected(AdapterView&lt;?&gt; parent) {
if (DBG)
                Log.d(LOG_TAG, "onNothingSelected()");
        }
    };

    /**
     * Query rewriting.
     */
    private void rewriteQueryFromSuggestion(int position) {
        CharSequence oldQuery = mSearchSrcTextView.getText();
        Cursor c = mSuggestionsAdapter.getCursor();
        if (c == null) {
return;
        }
if (c.moveToPosition(position)) {
// Get the new query from the suggestion.
            CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
            if (newQuery != null) {
// The suggestion rewrites the query.
                // Update the text field, without getting new suggestions.
                setQuery(newQuery);
            } else {
// The suggestion does not rewrite the query, restore the user's query.
                setQuery(oldQuery);
            }
        } else {
// We got a bad position, restore the user's query.
            setQuery(oldQuery);
        }
    }

/**
     * Launches an intent based on a suggestion.
     *
     * @param position The index of the suggestion to create the intent from.
     * @param actionKey The key code of the action key that was pressed,
     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
     * @param actionMsg The message for the action key that was pressed,
     *        or &lt;code&gt;null&lt;/code&gt; if none.
     * @return true if a successful launch, false if could not (e.g. bad position).
     */
    private boolean launchSuggestion(int position, int actionKey, String actionMsg) {
        Cursor c = mSuggestionsAdapter.getCursor();
        if ((c != null) &amp;&amp; c.moveToPosition(position)) {

            Intent intent = createIntentFromSuggestion(c, actionKey, actionMsg);

            // launch the intent
            launchIntent(intent);

            return true;
        }
return false;
    }

/**
     * Launches an intent, including any special intent handling.
     */
    private void launchIntent(Intent intent) {
if (intent == null) {
return;
        }
try {
// If the intent was created from a suggestion, it will always have an explicit
            // component here.
            getContext().startActivity(intent);
        } catch (RuntimeException ex) {
            Log.e(LOG_TAG, "Failed launch activity: " + intent, ex);
        }
    }

/**
     * Sets the text in the query box, without updating the suggestions.
     */
    private void setQuery(CharSequence query) {
mSearchSrcTextView.setText(query);
        // Move the cursor to the end
        mSearchSrcTextView.setSelection(TextUtils.isEmpty(query) ? 0 : query.length());
    }

private void launchQuerySearch(int actionKey, String actionMsg, String query) {
        String action = Intent.ACTION_SEARCH;
        Intent intent = createIntent(action, null, null, query, actionKey, actionMsg);
        getContext().startActivity(intent);
    }

/**
     * Constructs an intent from the given information and the search dialog state.
     *
     * @param action Intent action.
     * @param data Intent data, or &lt;code&gt;null&lt;/code&gt;.
     * @param extraData Data for {@link SearchManager#EXTRA_DATA_KEY} or &lt;code&gt;null&lt;/code&gt;.
     * @param query Intent query, or &lt;code&gt;null&lt;/code&gt;.
     * @param actionKey The key code of the action key that was pressed,
     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
     * @param actionMsg The message for the action key that was pressed,
     *        or &lt;code&gt;null&lt;/code&gt; if none.
     * @return The intent.
     */
    private Intent createIntent(String action, Uri data, String extraData, String query,
            int actionKey, String actionMsg) {
// Now build the Intent
        Intent intent = new Intent(action);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want. We don't want to do this in in-app search though,
        // as it can be destructive to the activity stack.
        if (data != null) {
            intent.setData(data);
        }
        intent.putExtra(SearchManager.USER_QUERY, mUserQuery);
        if (query != null) {
            intent.putExtra(SearchManager.QUERY, query);
        }
if (extraData != null) {
            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
        }
if (mAppSearchData != null) {
            intent.putExtra(SearchManager.APP_DATA, mAppSearchData);
        }
if (actionKey != KeyEvent.KEYCODE_UNKNOWN) {
            intent.putExtra(SearchManager.ACTION_KEY, actionKey);
            intent.putExtra(SearchManager.ACTION_MSG, actionMsg);
        }
        intent.setComponent(mSearchable.getSearchActivity());
        return intent;
    }

/**
     * Create and return an Intent that can launch the voice search activity for web search.
     */
    private Intent createVoiceWebSearchIntent(Intent baseIntent, SearchableInfo searchable) {
        Intent voiceIntent = new Intent(baseIntent);
        ComponentName searchActivity = searchable.getSearchActivity();
        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null
                : searchActivity.flattenToShortString());
        return voiceIntent;
    }

/**
     * Create and return an Intent that can launch the voice search activity, perform a specific
     * voice transcription, and forward the results to the searchable activity.
     *
     * @param baseIntent The voice app search intent to start from
     * @return A completely-configured intent ready to send to the voice search activity
     */
    private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {
        ComponentName searchActivity = searchable.getSearchActivity();

        // create the necessary intent to set up a search-and-forward operation
        // in the voice search system.   We have to keep the bundle separate,
        // because it becomes immutable once it enters the PendingIntent
        Intent queryIntent = new Intent(Intent.ACTION_SEARCH);
        queryIntent.setComponent(searchActivity);
        PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent,
                PendingIntent.FLAG_ONE_SHOT);

        // Now set up the bundle that will be inserted into the pending intent
        // when it's time to do the search.  We always build it here (even if empty)
        // because the voice search activity will always need to insert "QUERY" into
        // it anyway.
        Bundle queryExtras = new Bundle();
        if (mAppSearchData != null) {
            queryExtras.putParcelable(SearchManager.APP_DATA, mAppSearchData);
        }

// Now build the intent to launch the voice search.  Add all necessary
        // extras to launch the voice recognizer, and then all the necessary extras
        // to forward the results to the searchable activity
        Intent voiceIntent = new Intent(baseIntent);

        // Add all of the configuration options supplied by the searchable's metadata
        String languageModel = RecognizerIntent.LANGUAGE_MODEL_FREE_FORM;
        String prompt = null;
        String language = null;
        int maxResults = 1;

        Resources resources = getResources();
        if (searchable.getVoiceLanguageModeId() != 0) {
            languageModel = resources.getString(searchable.getVoiceLanguageModeId());
        }
if (searchable.getVoicePromptTextId() != 0) {
            prompt = resources.getString(searchable.getVoicePromptTextId());
        }
if (searchable.getVoiceLanguageId() != 0) {
            language = resources.getString(searchable.getVoiceLanguageId());
        }
if (searchable.getVoiceMaxResults() != 0) {
            maxResults = searchable.getVoiceMaxResults();
        }

        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, languageModel);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, prompt);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null
                : searchActivity.flattenToShortString());

        // Add the values that configure forwarding the results
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT, pending);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT_BUNDLE, queryExtras);

        return voiceIntent;
    }

/**
     * When a particular suggestion has been selected, perform the various lookups required
     * to use the suggestion.  This includes checking the cursor for suggestion-specific data,
     * and/or falling back to the XML for defaults;  It also creates REST style Uri data when
     * the suggestion includes a data id.
     *
     * @param c The suggestions cursor, moved to the row of the user's selection
     * @param actionKey The key code of the action key that was pressed,
     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
     * @param actionMsg The message for the action key that was pressed,
     *        or &lt;code&gt;null&lt;/code&gt; if none.
     * @return An intent for the suggestion at the cursor's position.
     */
    private Intent createIntentFromSuggestion(Cursor c, int actionKey, String actionMsg) {
try {
// use specific action if supplied, or default action if supplied, or fixed default
            String action = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_ACTION);

            if (action == null) {
                action = mSearchable.getSuggestIntentAction();
            }
if (action == null) {
                action = Intent.ACTION_SEARCH;
            }

// use specific data if supplied, or default data if supplied
            String data = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA);
            if (data == null) {
                data = mSearchable.getSuggestIntentData();
            }
// then, if an ID was provided, append it.
            if (data != null) {
                String id = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);
                if (id != null) {
                    data = data + "/" + Uri.encode(id);
                }
            }
            Uri dataUri = (data == null) ? null : Uri.parse(data);

            String query = getColumnString(c, SearchManager.SUGGEST_COLUMN_QUERY);
            String extraData = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);

            return createIntent(action, dataUri, extraData, query, actionKey, actionMsg);
        } catch (RuntimeException e ) {
int rowNum;
            try {                       // be really paranoid now
                rowNum = c.getPosition();
            } catch (RuntimeException e2 ) {
                rowNum = -1;
            }
            Log.w(LOG_TAG, "Search suggestions cursor at row " + rowNum +
" returned exception.", e);
            return null;
        }
    }

private void forceSuggestionQuery() {
HIDDEN_METHOD_INVOKER.doBeforeTextChanged(mSearchSrcTextView);
        HIDDEN_METHOD_INVOKER.doAfterTextChanged(mSearchSrcTextView);
    }

static boolean isLandscapeMode(Context context) {
return context.getResources().getConfiguration().orientation
                == Configuration.ORIENTATION_LANDSCAPE;
    }

/**
     * Callback to watch the text field for empty/non-empty
     */
    private TextWatcher mTextWatcher = new TextWatcher() {
@Override
        public void beforeTextChanged(CharSequence s, int start, int before, int after) { }

@Override
        public void onTextChanged(CharSequence s, int start,
                int before, int after) {
            SearchView.this.onTextChanged(s);
        }

@Override
        public void afterTextChanged(Editable s) {
        }
    };

    private static class UpdatableTouchDelegate extends TouchDelegate {
/**
         * View that should receive forwarded touch events
         */
        private final View mDelegateView;

        /**
         * Bounds in local coordinates of the containing view that should be mapped to the delegate
         * view. This rect is used for initial hit testing.
         */
        private final Rect mTargetBounds;

        /**
         * Bounds in local coordinates of the containing view that are actual bounds of the delegate
         * view. This rect is used for event coordinate mapping.
         */
        private final Rect mActualBounds;

        /**
         * mTargetBounds inflated to include some slop. This rect is to track whether the motion events
         * should be considered to be be within the delegate view.
         */
        private final Rect mSlopBounds;

        private final int mSlop;

        /**
         * True if the delegate had been targeted on a down event (intersected mTargetBounds).
         */
        private boolean mDelegateTargeted;

        public UpdatableTouchDelegate(Rect targetBounds, Rect actualBounds, View delegateView) {
super(targetBounds, delegateView);
            mSlop = ViewConfiguration.get(delegateView.getContext()).getScaledTouchSlop();
            mTargetBounds = new Rect();
            mSlopBounds = new Rect();
            mActualBounds = new Rect();
            setBounds(targetBounds, actualBounds);
            mDelegateView = delegateView;
        }

public void setBounds(Rect desiredBounds, Rect actualBounds) {
mTargetBounds.set(desiredBounds);
            mSlopBounds.set(desiredBounds);
            mSlopBounds.inset(-mSlop, -mSlop);
            mActualBounds.set(actualBounds);
        }

@Override
        public boolean onTouchEvent(MotionEvent event) {
final int x = (int) event.getX();
            final int y = (int) event.getY();
            boolean sendToDelegate = false;
            boolean hit = true;
            boolean handled = false;

            switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
if (mTargetBounds.contains(x, y)) {
mDelegateTargeted = true;
                        sendToDelegate = true;
                    }
break;
                case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_MOVE:
                    sendToDelegate = mDelegateTargeted;
                    if (sendToDelegate) {
if (!mSlopBounds.contains(x, y)) {
                            hit = false;
                        }
                    }
break;
                case MotionEvent.ACTION_CANCEL:
                    sendToDelegate = mDelegateTargeted;
                    mDelegateTargeted = false;
                    break;
            }
if (sendToDelegate) {
if (hit &amp;&amp; !mActualBounds.contains(x, y)) {
// Offset event coordinates to be in the center of the target view since we
                    // are within the targetBounds, but not inside the actual bounds of
                    // mDelegateView
                    event.setLocation(mDelegateView.getWidth() / 2,
                            mDelegateView.getHeight() / 2);
                } else {
// Offset event coordinates to the target view coordinates.
                    event.setLocation(x - mActualBounds.left, y - mActualBounds.top);
                }

                handled = mDelegateView.dispatchTouchEvent(event);
            }
return handled;
        }
    }

/**
     * Local subclass for AutoCompleteTextView.
     * @hide
     */
    public static class SearchAutoComplete extends AppCompatAutoCompleteTextView {

private int mThreshold;
        private SearchView mSearchView;

        public SearchAutoComplete(Context context) {
this(context, null);
        }

public SearchAutoComplete(Context context, AttributeSet attrs) {
this(context, attrs, R.attr.autoCompleteTextViewStyle);
        }

public SearchAutoComplete(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
            mThreshold = getThreshold();
        }

@Override
        protected void onFinishInflate() {
super.onFinishInflate();
            DisplayMetrics metrics = getResources().getDisplayMetrics();
            setMinWidth((int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                    getSearchViewTextMinWidthDp(), metrics));
        }

void setSearchView(SearchView searchView) {
mSearchView = searchView;
        }

@Override
        public void setThreshold(int threshold) {
super.setThreshold(threshold);
            mThreshold = threshold;
        }

/**
         * Returns true if the text field is empty, or contains only whitespace.
         */
        private boolean isEmpty() {
return TextUtils.getTrimmedLength(getText()) == 0;
        }

/**
         * We override this method to avoid replacing the query box text when a
         * suggestion is clicked.
         */
        @Override
        protected void replaceText(CharSequence text) {
        }

/**
         * We override this method to avoid an extra onItemClick being called on
         * the drop-down's OnItemClickListener by
         * {@link AutoCompleteTextView#onKeyUp(int, KeyEvent)} when an item is
         * clicked with the trackball.
         */
        @Override
        public void performCompletion() {
        }

/**
         * We override this method to be sure and show the soft keyboard if
         * appropriate when the TextView has focus.
         */
        @Override
        public void onWindowFocusChanged(boolean hasWindowFocus) {
super.onWindowFocusChanged(hasWindowFocus);

            if (hasWindowFocus &amp;&amp; mSearchView.hasFocus() &amp;&amp; getVisibility() == VISIBLE) {
                InputMethodManager inputManager = (InputMethodManager) getContext()
                        .getSystemService(Context.INPUT_METHOD_SERVICE);
                inputManager.showSoftInput(this, 0);
                // If in landscape mode, then make sure that
                // the ime is in front of the dropdown.
                if (isLandscapeMode(getContext())) {
HIDDEN_METHOD_INVOKER.ensureImeVisible(this, true);
                }
            }
        }

@Override
        protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
super.onFocusChanged(focused, direction, previouslyFocusedRect);
            mSearchView.onTextFocusChanged();
        }

/**
         * We override this method so that we can allow a threshold of zero,
         * which ACTV does not.
         */
        @Override
        public boolean enoughToFilter() {
return mThreshold &lt;= 0 || super.enoughToFilter();
        }

@Override
        public boolean onKeyPreIme(int keyCode, KeyEvent event) {
if (keyCode == KeyEvent.KEYCODE_BACK) {
// special case for the back key, we do not even try to send it
                // to the drop down list but instead, consume it immediately
                if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.startTracking(event, this);
                    }
return true;
                } else if (event.getAction() == KeyEvent.ACTION_UP) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.handleUpEvent(event);
                    }
if (event.isTracking() &amp;&amp; !event.isCanceled()) {
mSearchView.clearFocus();
                        mSearchView.setImeVisibility(false);
                        return true;
                    }
                }
            }
return super.onKeyPreIme(keyCode, event);
        }

/**
         * Get minimum width of the search view text entry area.
         */
        private int getSearchViewTextMinWidthDp() {
final Configuration config = getResources().getConfiguration();
            final int widthDp = ConfigurationHelper.getScreenWidthDp(getResources());
            final int heightDp = ConfigurationHelper.getScreenHeightDp(getResources());

            if (widthDp &gt;= 960 &amp;&amp; heightDp &gt;= 720
                    &amp;&amp; config.orientation == Configuration.ORIENTATION_LANDSCAPE) {
return 256;
            } else if (widthDp &gt;= 600 || (widthDp &gt;= 640 &amp;&amp; heightDp &gt;= 480)) {
return 192;
            }
return 160;
        }
    }

private static class AutoCompleteTextViewReflector {
private Method doBeforeTextChanged, doAfterTextChanged;
        private Method ensureImeVisible;
        private Method showSoftInputUnchecked;

        AutoCompleteTextViewReflector() {
try {
doBeforeTextChanged = AutoCompleteTextView.class
                        .getDeclaredMethod("doBeforeTextChanged");
                doBeforeTextChanged.setAccessible(true);
            } catch (NoSuchMethodException e) {
// Ah well.
            }
try {
doAfterTextChanged = AutoCompleteTextView.class
                        .getDeclaredMethod("doAfterTextChanged");
                doAfterTextChanged.setAccessible(true);
            } catch (NoSuchMethodException e) {
// Ah well.
            }
try {
ensureImeVisible = AutoCompleteTextView.class
                        .getMethod("ensureImeVisible", boolean.class);
                ensureImeVisible.setAccessible(true);
            } catch (NoSuchMethodException e) {
// Ah well.
            }
try {
showSoftInputUnchecked = InputMethodManager.class.getMethod(
"showSoftInputUnchecked", int.class, ResultReceiver.class);
                showSoftInputUnchecked.setAccessible(true);
            } catch (NoSuchMethodException e) {
// Ah well.
            }
        }

void doBeforeTextChanged(AutoCompleteTextView view) {
if (doBeforeTextChanged != null) {
try {
doBeforeTextChanged.invoke(view);
                } catch (Exception e) {
                }
            }
        }

void doAfterTextChanged(AutoCompleteTextView view) {
if (doAfterTextChanged != null) {
try {
doAfterTextChanged.invoke(view);
                } catch (Exception e) {
                }
            }
        }

void ensureImeVisible(AutoCompleteTextView view, boolean visible) {
if (ensureImeVisible != null) {
try {
ensureImeVisible.invoke(view, visible);
                } catch (Exception e) {
                }
            }
        }

void showSoftInputUnchecked(InputMethodManager imm, View view, int flags) {
if (showSoftInputUnchecked != null) {
try {
showSoftInputUnchecked.invoke(imm, flags, null);
                    return;
                } catch (Exception e) {
                }
            }

// Hidden method failed, call public version instead
            imm.showSoftInput(view, flags);
        }
    }
}
</code></pre></div><p><b>End</b></p><br><p><b>希望大家关注我的知乎，和个人github/qydq ，转载标明出处，谢谢。</b></p></div><div class="PostIndex-footer"><div class="PostIndex-topics TopicItem-wrapper"><a class="TopicItem u-ellipsis PostIndex-topicItem" href="https://www.zhihu.com/topic/19555634"><!-- react-text: 41 -->Android 开发<!-- /react-text --></a><a class="TopicItem u-ellipsis PostIndex-topicItem" href="https://www.zhihu.com/topic/20005114"><!-- react-text: 43 -->Material Design<!-- /react-text --></a></div><div class="PostIndex-reviewers"></div><div class="PostIndex-vote"><button class="Button PostIndex-voteButton Button--green" aria-label="赞" type="button"><i class="icon icon-ic_column_like"></i><!-- react-text: 48 -->1<!-- /react-text --></button><div class="PostIndex-voters"><div class="HoverTitle HoverTitle--slim" data-hover-title="mylhyz"><a href="https://www.zhihu.com/people/mylhyz" class="PostIndex-voter" target="_blank"><img class="Avatar-hemingway Avatar--is" alt="mylhyz" src="./android （MD）v7.widget.SearchView的使用解析。_files/8315ba69e42d71b923528de886466418_is.jpg" srcset="https://pic1.zhimg.com/8315ba69e42d71b923528de886466418_im.jpg 2x"></a></div><a href="https://zhuanlan.zhihu.com/p/22388833/voters" target="_blank" rel="noopener noreferrer" title="查看全部" class="PostIndex-allVoters"><i class="icon-ic_like_more"></i></a></div></div><div class="PostIndex-control"><div class="Fav"><button class="Button Button Button--plain FavButton" type="button"><i class="icon icon-ic_collect"></i><!-- react-text: 59 -->收藏<!-- /react-text --></button><!-- react-empty: 60 --></div><div class="PostShare"><div class="Menu"><button class="Button Button Button--plain MenuButton MenuButton-listen-hover Button Button--plain" type="button"><i class="icon icon-ic_column_share"></i><!-- react-text: 65 -->分享<!-- /react-text --></button><div class="Menu-dropdown" style="visibility: hidden;"></div></div></div><div class="Report"><button class="Button Button Button--plain ReportButton" type="button"><i class="icon icon-ic_column_report"></i><!-- react-text: 70 -->举报<!-- /react-text --></button><!-- react-empty: 71 --></div></div></div><div class="Contributes PostIndex-contributes av-card"><div class="BlockTitle av-marginLeft av-borderColor"><span class="BlockTitle-title">文章被以下专栏收录</span><span class="BlockTitle-line"></span></div><ul class="Contributes-list"><li class="Contributes-listItem av-borderColor av-marginLeft" style="opacity: 1; max-height: 300px;"><div class="ContributesItem av-paddingRight" role="link"><a class="ContributesItem-avatar" href="https://zhuanlan.zhihu.com/qyddai"><img class="Avatar-hemingway" src="./android （MD）v7.widget.SearchView的使用解析。_files/v2-28a7c692cda8c760ec9a242440d652ac_m.jpg" srcset="https://pic1.zhimg.com/v2-28a7c692cda8c760ec9a242440d652ac_xl.jpg 2x"></a><div class="ContributesItem-info"><div class="ContributesItem-nameLine"><a class="ContributesItem-name" href="https://zhuanlan.zhihu.com/qyddai">Android开发</a></div><p class="ContributesItem-intro u-ellipsis">此专栏介绍android开发相关的只是</p></div><a class="ContributesItem-entrance" href="https://zhuanlan.zhihu.com/qyddai">进入专栏</a></div></li></ul></div><div class="PostComment"><div class="BlockTitle av-marginLeft av-borderColor PostComment-blockTitle"><span class="BlockTitle-title"><!-- react-text: 89 -->还没有评论<!-- /react-text --></span><span class="BlockTitle-line"></span></div><div class="CommentEditor PostComment-mainEditor"><!-- react-empty: 92 --><div class="CommentEditor-input"><div class="Input-wrapper Input-wrapper--spread Input-wrapper--large Input-wrapper--noPadding"><div class="Input Editable"><div class="Dropzone RichText" style="min-height: 38px;"><div class="DraftEditor-root"><div class="public-DraftEditorPlaceholder-root"><div class="public-DraftEditorPlaceholder-inner" id="placeholder-aqi4m">写下你的评论...</div></div><div class="DraftEditor-editorContainer"><div aria-describedby="placeholder-aqi4m" class="notranslate public-DraftEditor-content" contenteditable="true" role="textbox" spellcheck="true" tabindex="0" style="outline: none; white-space: pre-wrap; word-wrap: break-word;"><div data-contents="true"><div class="Editable-unstyled" data-block="true" data-editor="aqi4m" data-offset-key="6r8e2-0-0"><div data-offset-key="6r8e2-0-0" class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span data-offset-key="6r8e2-0-0"><br data-text="true"></span></div></div></div></div></div></div></div><input type="file" multiple="" accept="image/jpg,image/jpeg,image/png,image/gif" style="display: none;"><!-- react-empty: 216 --><!-- react-empty: 217 --><div></div><!-- react-empty: 219 --><!-- react-empty: 220 --><!-- react-empty: 221 --></div></div><div class="CommentEditor-actions"><button class="Button Button--plain" type="button"><!-- react-text: 97 -->取消<!-- /react-text --></button><button class="Button Button--blue" disabled="" type="button"><!-- react-text: 99 -->评论<!-- /react-text --></button></div></div></div><div class="PostCommentList"></div><!-- react-empty: 101 --><!-- react-empty: 102 --></div><div class="PostIndex-recommendZone av-card"><div class="BlockTitle av-marginLeft av-borderColor"><span class="BlockTitle-title">推荐阅读</span><span class="BlockTitle-line"></span></div><ul class="PostIndex-recommends"><li class="PostIndex-recommendItem av-marginLeft av-borderColor"><div class="PostListItem PostListItem--narrow av-paddingRight"><a class="PostListItem-titleImageWrapper" href="https://zhuanlan.zhihu.com/p/22424181"><img src="./android （MD）v7.widget.SearchView的使用解析。_files/b7153a2776958d2529f8429401e533ad_b.jpg" class="PostListItem-titleImage" alt="题图"></a><div class="PostListItem-info"><a href="https://zhuanlan.zhihu.com/p/22424181"><span class="PostListItem-title">eclipse快速配置Maven plugin 安装</span><p class="PostListItem-summary"><!-- react-text: 122 -->maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分…<!-- /react-text --><span class="PostListItem-readall"><!-- react-text: 124 -->查看全文<!-- /react-text --><i class="icon icon-ic_unfold"></i></span></p></a><div class="PostListItem-footer"><span><a class="PostListItem-name" target="_blank" href="https://www.zhihu.com/people/qydq">Bgwan</a><span class="Bull"></span><div class="HoverTitle PostListItem-date" data-hover-title="2016 年 9月 13 日星期二上午 9 点 43 分"><time datetime="2016-09-13T09:43:23+08:00">1 年前</time></div><span class="PostListItem-source"><span class="Bull"></span><span class="PostListItem-sourcePrefix">发表于 </span><a title="Android开发" href="https://zhuanlan.zhihu.com/qyddai">Android开发</a></span></span></div></div></div></li><li class="PostIndex-recommendItem av-marginLeft av-borderColor"><div class="PostListItem PostListItem--narrow av-paddingRight"><a class="PostListItem-titleImageWrapper" href="https://zhuanlan.zhihu.com/p/22362839"><img src="./android （MD）v7.widget.SearchView的使用解析。_files/b7153a2776958d2529f8429401e533ad_b.jpg" class="PostListItem-titleImage" alt="题图"></a><div class="PostListItem-info"><a href="https://zhuanlan.zhihu.com/p/22362839"><span class="PostListItem-title">RecyclerView解析之下拉刷新与上拉加载SwipeRefreshLayout（含分割线工具类）</span><p class="PostListItem-summary"><!-- react-text: 144 -->标题的图片盗用google+ 上面 Ankita Narayan美女的； 附上地址她的主页，外国人应该不太用知…<!-- /react-text --><span class="PostListItem-readall"><!-- react-text: 146 -->查看全文<!-- /react-text --><i class="icon icon-ic_unfold"></i></span></p></a><div class="PostListItem-footer"><span><a class="PostListItem-name" target="_blank" href="https://www.zhihu.com/people/qydq">Bgwan</a><span class="Bull"></span><div class="HoverTitle PostListItem-date" data-hover-title="2016 年 9月 8 日星期四下午 2 点 28 分"><time datetime="2016-09-08T14:28:49+08:00">1 年前</time></div><span class="PostListItem-source"><span class="Bull"></span><span class="PostListItem-sourcePrefix">发表于 </span><a title="Android开发" href="https://zhuanlan.zhihu.com/qyddai">Android开发</a></span></span></div></div></div></li><li class="PostIndex-recommendItem av-marginLeft av-borderColor"><div class="PostListItem PostListItem--narrow av-paddingRight"><a class="PostListItem-titleImageWrapper" href="https://zhuanlan.zhihu.com/p/23357071"><img src="./android （MD）v7.widget.SearchView的使用解析。_files/v2-8729729e8b5b76035902e150c9e5c04c_b.jpg" class="PostListItem-titleImage" alt="题图"></a><div class="PostListItem-info"><a href="https://zhuanlan.zhihu.com/p/23357071"><span class="PostListItem-title">Android App Shortcuts</span><p class="PostListItem-summary"><!-- react-text: 166 -->简介Android 7.1允许您定义应用程序中特定操作的快捷方式。这些快捷键可以显示桌面，例如Nex…<!-- /react-text --><span class="PostListItem-readall"><!-- react-text: 168 -->查看全文<!-- /react-text --><i class="icon icon-ic_unfold"></i></span></p></a><div class="PostListItem-footer"><span><a class="PostListItem-name" target="_blank" href="https://www.zhihu.com/people/wuxiaolong.me">吴小龙同學</a><span class="Bull"></span><div class="HoverTitle PostListItem-date" data-hover-title="2016 年 11月 1 日星期二晚上 9 点 45 分"><time datetime="2016-11-01T21:45:14+08:00">1 年前</time></div><span class="PostListItem-source"><span class="Bull"></span><span class="PostListItem-sourcePrefix">发表于 </span><a title="吴小龙同学" href="https://zhuanlan.zhihu.com/WuXiaolong">吴小龙同学</a></span></span></div></div></div></li><li class="PostIndex-recommendItem av-marginLeft av-borderColor"><div class="PostListItem PostListItem--narrow av-paddingRight"><a class="PostListItem-titleImageWrapper" href="https://zhuanlan.zhihu.com/p/23122834"><img src="./android （MD）v7.widget.SearchView的使用解析。_files/v2-8bc255e4593190e930eb6dd109829040_b.jpg" class="PostListItem-titleImage" alt="题图"></a><div class="PostListItem-info"><a href="https://zhuanlan.zhihu.com/p/23122834"><span class="PostListItem-title">Android Design Support Library之BottomNavigation</span><p class="PostListItem-summary"><!-- react-text: 188 -->随着Android 7.1的的发布，相关的开发工具与套件也一起更新了，包括Android Studio 2.2.2与S…<!-- /react-text --><span class="PostListItem-readall"><!-- react-text: 190 -->查看全文<!-- /react-text --><i class="icon icon-ic_unfold"></i></span></p></a><div class="PostListItem-footer"><span><a class="PostListItem-name" target="_blank" href="https://www.zhihu.com/people/wuxiaolong.me">吴小龙同學</a><span class="Bull"></span><div class="HoverTitle PostListItem-date" data-hover-title="2016 年 10月 22 日星期六凌晨 12 点 51 分"><time datetime="2016-10-22T00:51:44+08:00">1 年前</time></div><span class="PostListItem-source"><span class="Bull"></span><span class="PostListItem-sourcePrefix">发表于 </span><a title="吴小龙同学" href="https://zhuanlan.zhihu.com/WuXiaolong">吴小龙同学</a></span></span></div></div></div></li></ul></div><!-- react-empty: 103 --><!-- react-empty: 104 --></div></div><!-- react-empty: 105 --><!-- react-empty: 106 --><!-- react-empty: 107 --></div></div><textarea id="clientConfig" hidden="">{"debug":false,"apiRoot":"","paySDK":"https:\u002F\u002Fpay.zhihu.com\u002Fapi\u002Fjs","wechatConfigAPI":"\u002Fapi\u002Fwechat\u002Fjssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":"\"AFCC61jyRAuPTiFFKv0o4YTdmZb-FkQUEwc=|1486385493\"","Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea><textarea id="preloadedState" hidden="">{"database":{"Post":{"22388833":{"isPending":false,"contributes":[{"sourceColumn":{"lastUpdated":1473301477,"description":"此专栏为android进阶应用场景，主要侧重MD设计，设计。","permission":"COLUMN_PUBLIC","memberId":40571531,"contributePermission":"COLUMN_PUBLIC","translatedCommentPermission":"all","canManage":true,"intro":"此专栏介绍android开发相关的只是","urlToken":"qyddai","id":19471,"imagePath":"v2-28a7c692cda8c760ec9a242440d652ac.jpg","slug":"qyddai","applyReason":"0","name":"Android开发","title":"Android开发","url":"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fqyddai","commentPermission":"COLUMN_ALL_CAN_COMMENT","canPost":true,"created":1473047844,"state":"COLUMN_NORMAL","followers":130,"avatar":{"id":"v2-28a7c692cda8c760ec9a242440d652ac","template":"https:\u002F\u002Fpic1.zhimg.com\u002F{id}_{size}.jpg"},"activateAuthorRequested":false,"following":false,"imageUrl":"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-28a7c692cda8c760ec9a242440d652ac_l.jpg","articlesCount":29},"state":"accepted","targetPost":{"titleImage":"https:\u002F\u002Fpic4.zhimg.com\u002Fb7153a2776958d2529f8429401e533ad_r.jpg","lastUpdated":1491803356,"imagePath":"b7153a2776958d2529f8429401e533ad.jpg","permission":"ARTICLE_PUBLIC","topics":[1800,153750],"summary":"\u003Cb\u003EBegin\u003C\u002Fb\u003E末尾附上SearchView的源代码。 SearchView是google在v7后面引入的一个搜索的控件，今天不是第一次使用这个控件了，很早之前实现SeachView的办法是自定义View，既然android官方网站已经给出了这个View我们就没有再去自定义SeachView了。SearchView包含…","copyPermission":"ARTICLE_COPYABLE","translatedCommentPermission":"all","likes":0,"origAuthorId":0,"publishedTime":"2016-09-10T10:28:20+08:00","sourceUrl":"","urlToken":22388833,"id":1140415,"withContent":false,"slug":22388833,"bigTitleImage":false,"title":"android （MD）v7.widget.SearchView的使用解析。","url":"\u002Fp\u002F22388833","commentPermission":"ARTICLE_ALL_CAN_COMMENT","snapshotUrl":"","created":1473474500,"comments":0,"columnId":19471,"content":"","parentId":0,"state":"ARTICLE_PUBLISHED","imageUrl":"https:\u002F\u002Fpic4.zhimg.com\u002Fb7153a2776958d2529f8429401e533ad_r.jpg","author":{"bio":"即时通讯，软件设计与开发者，物联网，移动互联网，AIVRVI兴趣者","isFollowing":false,"hash":"071d1fea34ab3dc8850d9aa78d844fdb","uid":664439680704057300,"isOrg":false,"slug":"qydq","isFollowed":false,"description":"专注于物联网领域，世界的通信标准从今开始改变，手机也可以是路由器，成功于视频直播,标准并不一定是Http\u002Fs，也可以是Bluetooth。","name":"Bgwan","profileUrl":"https:\u002F\u002Fwww.zhihu.com\u002Fpeople\u002Fqydq","avatar":{"id":"464372bfcc3e304100f3cad266280fd5","template":"https:\u002F\u002Fpic2.zhimg.com\u002F{id}_{size}.jpg"},"isOrgWhiteList":false,"isBanned":false},"memberId":40571531,"excerptTitle":"","voteType":"ARTICLE_VOTE_CLEAR"},"id":429355}],"title":"android （MD）v7.widget.SearchView的使用解析。","author":"qydq","content":"\u003Cb\u003EBegin\u003C\u002Fb\u003E\u003Cp\u003E末尾附上SearchView的源代码。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003ESearchView是google在v7后面引入的一个搜索的控件，今天不是第一次使用这个控件了，很早之前实现SeachView的办法是自定义View，既然android官方网站已经给出了这个View我们就没有再去自定义SeachView了。\u003C\u002Fp\u003E\u003Cp\u003ESearchView包含了很多新特性，在我的项目中很多的搜索功能都是通过SearchView来实现的，这次又要用到，所以写了这篇文章来吸粉。这个控件给我们封装了很多功能，也正因为这个，SearchView很多样式不好控制，比如输入框的背景图片，输入框的字体颜色等等！ 不过，\u003Cb\u003E看过分析过源码的朋友\u003C\u002Fb\u003E应该很容易实现这些功能，下面介绍如何使用SearchView。\u003C\u002Fp\u003E\u003Cp\u003E第一步：定义menu.xml  ,或者是在layout中加入SearchView控件即可，如以下方式。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E&amp;lt;menu xmlns:android=\"http:\u002F\u002Fschemas.android.com\u002Fapk\u002Fres\u002Fandroid\"\n    xmlns:app=\"http:\u002F\u002Fschemas.android.com\u002Fapk\u002Fres-auto\"\n    xmlns:tools=\"http:\u002F\u002Fschemas.android.com\u002Ftools\"\n    tools:context=\".LauncherActivity\"&amp;gt;\n\n    &amp;lt;item\n        android:id=\"@+id\u002Fsearch_contact\"\n        android:title=\"搜索\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always\" \u002F&amp;gt;\n&amp;lt;\u002Fmenu&amp;gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E或者：（区别是一个是菜单一个是layout）\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E&amp;lt;android.support.v7.widget.SearchView\n    android:id=\"@+id\u002FsearchView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"48dp\"\n    android:focusable=\"false\"\n    android:iconifiedByDefault=\"true\"\n    android:inputType=\"textFilter\"\n    android:queryHint=\"请输入您要查找的内容\"\n    android:textColor=\"#ABABAB\"\n    android:textColorHint=\"#ABABAB\" \u002F&amp;gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E第二步：获取SearchView控件，如下两种方式，\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003EsearchView = (SearchView) findViewById(R.id.searchView);\nlistView = (ListView) findViewById(R.id.listView);\nlistView.setTextFilterEnabled(true);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E或者：\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    getMenuInflater().inflate(R.menu.menu_search, menu);\n    final MenuItem item = menu.findItem(R.id.search_contact);\n    mSearchView = (SearchView) MenuItemCompat.getActionView(item);\n    return true;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E获取到SearchView我们就可以设置相应的特征了，比如说，让SearchView一开始获得焦点我们可以使用如下属性。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003EsearchView.setIconified(false);\nsearchView.setQueryHint(\"请输入您要查找的内容\");\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E或者用setQueryHint给出提示信息。如果不想它显示获得焦点可以使用下面的属性。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003EmSearchView.setIconifiedByDefault(false);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E第三步：设置SearchView的监听，点击事件。\u003C\u002Fp\u003E\u003Cp\u003EonQueryTextSumit即是你提交搜索是调用的方法，然后onQueryTextchange是你输入框中的文本发生变化时调用的方法。代码如下面参考。\u003C\u002Fp\u003E\u003Cp\u003E备注：这里使用了Snackbar的MD，有时间可能会解析这部分源代码。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003EsearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n@Override\n    public boolean onQueryTextSubmit(String query) {\nif (query.length() != 0) {\nmSearchText = query;\n            _loadData();\n\n        } else {\nlistView.clearTextFilter();\n            Snackbar.make(searchView, \"搜索不能为空\", Snackbar.LENGTH_LONG).setAction(\"Undo\",\n                    new View.OnClickListener() {\n@Override\n                        public void onClick(View v) {\n                            Toast.makeText(getApplication(), \"请输入内容后再试试\", Toast.LENGTH_SHORT).show();\n                        }\n                    }).show();\n        }\n\nreturn false;\n    }\n\n@Override\n    public boolean onQueryTextChange(String newText) {\nif (newText.length() != 0) {\nmSearchText = newText;\n            listView.setFilterText(newText);\n\n        } else {\nlistView.clearTextFilter();\n        }\nreturn false;\n    }\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E第四步：以上就是简单实用SearchView的基本步骤，那么你是否存在疑问，如果我们要修改样式，比如说提示信息的文字的字体大小，还有，字体，背景颜色那应该如何处理呢。我在源码中找到这样如下的变量声明。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003Eprivate final SearchAutoComplete mSearchSrcTextView;\nprivate final View mSearchEditFrame;\nprivate final View mSearchPlate;\nprivate final View mSubmitArea;\nprivate final ImageView mSearchButton;\nprivate final ImageView mGoButton;\nprivate final ImageView mCloseButton;\nprivate final ImageView mVoiceButton;\nprivate final View mDropDownAnchor;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E看到没有，SearchAutocomplete ，再继续源码追钟，发现该类是继承与EditText ，mSearchButton ,View 和这个类似，那么我自然知道如何修改Searchview的样式了。如下代码，找到SearchAutocompete，然后设置相应的属性即可。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003EmEdit = (SearchView.SearchAutoComplete) searchView.findViewById(R.id.search_src_text);\nmEdit.setTextSize(14);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E其实这里还用了另外一种方法获取 id \u003Cbr\u003EcloseImgId = context.getResources().getIdentifier(“search_close_btn”, “id”, getPackageName())\u003Cbr\u003E其实直接用 R.id.search_close_btn是一样的，没有区别！\u003C\u002Fp\u003E\u003Cp\u003E我相信经过上面的分析，你已经能迅速并且完美的使用该新控件了，其实重要代码就是searchView.findViewById(R.id.search_src_text);\u003C\u002Fp\u003E\u003Cp\u003E第五步：附上SearchView的源代码，你从这里可以直接查看（很多很多）。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E*****\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=http%3A\u002F\u002Fbgwan.blog.163.com\u002F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E希望大家关注我的知乎，和个人github\u002Fqydq ，转载标明出处，谢谢。\u003C\u002Fa\u003E*****\u003C\u002Fb\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003ESearchView.java\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E\u002F*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\u002F\u002Fwww.apache.org\u002Flicenses\u002FLICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\u002F\n\npackage android.support.v7.widget;\n\n\u002F**\n * A widget that provides a user interface for the user to enter a search query and submit a request\n * to a search provider. Shows a list of query suggestions or results, if available, and allows the\n * user to pick a suggestion or result to launch into.\n *\n * &amp;lt;p class=\"note\"&amp;gt;&amp;lt;strong&amp;gt;Note:&amp;lt;\u002Fstrong&amp;gt; This class is included in the &amp;lt;a\n * href=\"{@docRoot}tools\u002Fextras\u002Fsupport-library.html\"&amp;gt;support library&amp;lt;\u002Fa&amp;gt; for compatibility\n * with API level 7 and higher. If you're developing your app for API level 11 and higher\n * &amp;lt;em&amp;gt;only&amp;lt;\u002Fem&amp;gt;, you should instead use the framework {@link android.widget.SearchView} class.&amp;lt;\u002Fp&amp;gt;\n *\n * &amp;lt;p&amp;gt;\n * When the SearchView is used in an {@link android.support.v7.app.ActionBar}\n * as an action view, it's collapsed by default, so you must provide an icon for the action.\n * &amp;lt;\u002Fp&amp;gt;\n * &amp;lt;p&amp;gt;\n * If you want the search field to always be visible, then call\n * {@link #setIconifiedByDefault(boolean) setIconifiedByDefault(false)}.\n * &amp;lt;\u002Fp&amp;gt;\n *\n * &amp;lt;div class=\"special reference\"&amp;gt;\n * &amp;lt;h3&amp;gt;Developer Guides&amp;lt;\u002Fh3&amp;gt;\n * &amp;lt;p&amp;gt;For information about using {@code SearchView}, read the\n * &amp;lt;a href=\"{@docRoot}guide\u002Ftopics\u002Fsearch\u002Findex.html\"&amp;gt;Search&amp;lt;\u002Fa&amp;gt; API guide.\n * Additional information about action views is also available in the &amp;lt;&amp;lt;a\n * href=\"{@docRoot}guide\u002Ftopics\u002Fui\u002Factionbar.html#ActionView\"&amp;gt;Action Bar&amp;lt;\u002Fa&amp;gt; API guide&amp;lt;\u002Fp&amp;gt;\n * &amp;lt;\u002Fdiv&amp;gt;\n *\n * @see android.support.v4.view.MenuItemCompat#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW\n *\u002F\npublic class SearchView extends LinearLayoutCompat implements CollapsibleActionView {\n\nprivate static final boolean DBG = false;\n    private static final String LOG_TAG = \"SearchView\";\n\n    \u002F**\n     * Private constant for removing the microphone in the keyboard.\n     *\u002F\n    private static final String IME_OPTION_NO_MICROPHONE = \"nm\";\n\n    private final SearchAutoComplete mSearchSrcTextView;\n    private final View mSearchEditFrame;\n    private final View mSearchPlate;\n    private final View mSubmitArea;\n    private final ImageView mSearchButton;\n    private final ImageView mGoButton;\n    private final ImageView mCloseButton;\n    private final ImageView mVoiceButton;\n    private final View mDropDownAnchor;\n\n    private UpdatableTouchDelegate mTouchDelegate;\n    private Rect mSearchSrcTextViewBounds = new Rect();\n    private Rect mSearchSrtTextViewBoundsExpanded = new Rect();\n    private int[] mTemp = new int[2];\n    private int[] mTemp2 = new int[2];\n\n    \u002F** Icon optionally displayed when the SearchView is collapsed. *\u002F\n    private final ImageView mCollapsedIcon;\n\n    \u002F** Drawable used as an EditText hint. *\u002F\n    private final Drawable mSearchHintIcon;\n\n    \u002F\u002F Resources used by SuggestionsAdapter to display suggestions.\n    private final int mSuggestionRowLayout;\n    private final int mSuggestionCommitIconResId;\n\n    \u002F\u002F Intents used for voice searching.\n    private final Intent mVoiceWebSearchIntent;\n    private final Intent mVoiceAppSearchIntent;\n\n    private final CharSequence mDefaultQueryHint;\n\n    private OnQueryTextListener mOnQueryChangeListener;\n    private OnCloseListener mOnCloseListener;\n    private OnFocusChangeListener mOnQueryTextFocusChangeListener;\n    private OnSuggestionListener mOnSuggestionListener;\n    private OnClickListener mOnSearchClickListener;\n\n    private boolean mIconifiedByDefault;\n    private boolean mIconified;\n    private CursorAdapter mSuggestionsAdapter;\n    private boolean mSubmitButtonEnabled;\n    private CharSequence mQueryHint;\n    private boolean mQueryRefinement;\n    private boolean mClearingFocus;\n    private int mMaxWidth;\n    private boolean mVoiceButtonEnabled;\n    private CharSequence mOldQueryText;\n    private CharSequence mUserQuery;\n    private boolean mExpandedInActionView;\n    private int mCollapsedImeOptions;\n\n    private SearchableInfo mSearchable;\n    private Bundle mAppSearchData;\n\n    static final AutoCompleteTextViewReflector HIDDEN_METHOD_INVOKER = new AutoCompleteTextViewReflector();\n\n    \u002F*\n     * SearchView can be set expanded before the IME is ready to be shown during\n     * initial UI setup. The show operation is asynchronous to account for this.\n     *\u002F\n    private Runnable mShowImeRunnable = new Runnable() {\n@Override\n        public void run() {\n            InputMethodManager imm = (InputMethodManager)\n                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\n\n            if (imm != null) {\nHIDDEN_METHOD_INVOKER.showSoftInputUnchecked(imm, SearchView.this, 0);\n            }\n        }\n    };\n\n    private final Runnable mUpdateDrawableStateRunnable = new Runnable() {\n@Override\n        public void run() {\n            updateFocusedState();\n        }\n    };\n\n    private Runnable mReleaseCursorRunnable = new Runnable() {\n@Override\n        public void run() {\nif (mSuggestionsAdapter != null &amp;amp;&amp;amp; mSuggestionsAdapter instanceof SuggestionsAdapter) {\nmSuggestionsAdapter.changeCursor(null);\n            }\n        }\n    };\n\n    \u002F\u002F A weak map of drawables we've gotten from other packages, so we don't load them\n    \u002F\u002F more than once.\n    private final WeakHashMap&amp;lt;String, Drawable.ConstantState&amp;gt; mOutsideDrawablesCache =\nnew WeakHashMap&amp;lt;String, Drawable.ConstantState&amp;gt;();\n\n    \u002F**\n     * Callbacks for changes to the query text.\n     *\u002F\n    public interface OnQueryTextListener {\n\n\u002F**\n         * Called when the user submits the query. This could be due to a key press on the\n         * keyboard or due to pressing a submit button.\n         * The listener can override the standard behavior by returning true\n         * to indicate that it has handled the submit request. Otherwise return false to\n         * let the SearchView handle the submission by launching any associated intent.\n         *\n         * @param query the query text that is to be submitted\n         *\n         * @return true if the query has been handled by the listener, false to let the\n         * SearchView perform the default action.\n         *\u002F\n        boolean onQueryTextSubmit(String query);\n\n        \u002F**\n         * Called when the query text is changed by the user.\n         *\n         * @param newText the new content of the query text field.\n         *\n         * @return false if the SearchView should perform the default action of showing any\n         * suggestions if available, true if the action was handled by the listener.\n         *\u002F\n        boolean onQueryTextChange(String newText);\n    }\n\npublic interface OnCloseListener {\n\n\u002F**\n         * The user is attempting to close the SearchView.\n         *\n         * @return true if the listener wants to override the default behavior of clearing the\n         * text field and dismissing it, false otherwise.\n         *\u002F\n        boolean onClose();\n    }\n\n\u002F**\n     * Callback interface for selection events on suggestions. These callbacks\n     * are only relevant when a SearchableInfo has been specified by {@link #setSearchableInfo}.\n     *\u002F\n    public interface OnSuggestionListener {\n\n\u002F**\n         * Called when a suggestion was selected by navigating to it.\n         * @param position the absolute position in the list of suggestions.\n         *\n         * @return true if the listener handles the event and wants to override the default\n         * behavior of possibly rewriting the query based on the selected item, false otherwise.\n         *\u002F\n        boolean onSuggestionSelect(int position);\n\n        \u002F**\n         * Called when a suggestion was clicked.\n         * @param position the absolute position of the clicked item in the list of suggestions.\n         *\n         * @return true if the listener handles the event and wants to override the default\n         * behavior of launching any intent or submitting a search query specified on that item.\n         * Return false otherwise.\n         *\u002F\n        boolean onSuggestionClick(int position);\n    }\n\npublic SearchView(Context context) {\nthis(context, null);\n    }\n\npublic SearchView(Context context, AttributeSet attrs) {\nthis(context, attrs, R.attr.searchViewStyle);\n    }\n\npublic SearchView(Context context, AttributeSet attrs, int defStyleAttr) {\nsuper(context, attrs, defStyleAttr);\n\n        final TintTypedArray a = TintTypedArray.obtainStyledAttributes(context,\n                attrs, R.styleable.SearchView, defStyleAttr, 0);\n\n        final LayoutInflater inflater = LayoutInflater.from(context);\n        final int layoutResId = a.getResourceId(\n                R.styleable.SearchView_layout, R.layout.abc_search_view);\n        inflater.inflate(layoutResId, this, true);\n\n        mSearchSrcTextView = (SearchAutoComplete) findViewById(R.id.search_src_text);\n        mSearchSrcTextView.setSearchView(this);\n\n        mSearchEditFrame = findViewById(R.id.search_edit_frame);\n        mSearchPlate = findViewById(R.id.search_plate);\n        mSubmitArea = findViewById(R.id.submit_area);\n        mSearchButton = (ImageView) findViewById(R.id.search_button);\n        mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n        mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n        mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n        mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n\n        \u002F\u002F Set up icons and backgrounds.\n        mSearchPlate.setBackgroundDrawable(a.getDrawable(R.styleable.SearchView_queryBackground));\n        mSubmitArea.setBackgroundDrawable(a.getDrawable(R.styleable.SearchView_submitBackground));\n        mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n        mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n        mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n        mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n        mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n\n        mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n\n        \u002F\u002F Extract dropdown layout resource IDs for later use.\n        mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout,\n                R.layout.abc_search_dropdown_item_icons_2line);\n        mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n\n        mSearchButton.setOnClickListener(mOnClickListener);\n        mCloseButton.setOnClickListener(mOnClickListener);\n        mGoButton.setOnClickListener(mOnClickListener);\n        mVoiceButton.setOnClickListener(mOnClickListener);\n        mSearchSrcTextView.setOnClickListener(mOnClickListener);\n\n        mSearchSrcTextView.addTextChangedListener(mTextWatcher);\n        mSearchSrcTextView.setOnEditorActionListener(mOnEditorActionListener);\n        mSearchSrcTextView.setOnItemClickListener(mOnItemClickListener);\n        mSearchSrcTextView.setOnItemSelectedListener(mOnItemSelectedListener);\n        mSearchSrcTextView.setOnKeyListener(mTextKeyListener);\n\n        \u002F\u002F Inform any listener of focus changes\n        mSearchSrcTextView.setOnFocusChangeListener(new OnFocusChangeListener() {\n@Override\n            public void onFocusChange(View v, boolean hasFocus) {\nif (mOnQueryTextFocusChangeListener != null) {\nmOnQueryTextFocusChangeListener.onFocusChange(SearchView.this, hasFocus);\n                }\n            }\n        });\n        setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n\n        final int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n        if (maxWidth != -1) {\n            setMaxWidth(maxWidth);\n        }\n\nmDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n        mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n\n        final int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n        if (imeOptions != -1) {\n            setImeOptions(imeOptions);\n        }\n\nfinal int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n        if (inputType != -1) {\n            setInputType(inputType);\n        }\n\nboolean focusable = true;\n        focusable = a.getBoolean(R.styleable.SearchView_android_focusable, focusable);\n        setFocusable(focusable);\n\n        a.recycle();\n\n        \u002F\u002F Save voice intent for later queries\u002Flaunching\n        mVoiceWebSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);\n        mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,\n                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);\n\n        mVoiceAppSearchIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n        mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        mDropDownAnchor = findViewById(mSearchSrcTextView.getDropDownAnchor());\n        if (mDropDownAnchor != null) {\nif (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.HONEYCOMB) {\n                addOnLayoutChangeListenerToDropDownAnchorSDK11();\n            } else {\n                addOnLayoutChangeListenerToDropDownAnchorBase();\n            }\n        }\n\n        updateViewsVisibility(mIconifiedByDefault);\n        updateQueryHint();\n    }\n\n@TargetApi(Build.VERSION_CODES.HONEYCOMB)\nprivate void addOnLayoutChangeListenerToDropDownAnchorSDK11() {\nmDropDownAnchor.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {\n@Override\n            public void onLayoutChange(View v, int left, int top, int right, int bottom,\n                    int oldLeft, int oldTop, int oldRight, int oldBottom) {\n                adjustDropDownSizeAndPosition();\n            }\n        });\n    }\n\nprivate void addOnLayoutChangeListenerToDropDownAnchorBase() {\nmDropDownAnchor.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n@Override\n                    public void onGlobalLayout() {\n                        adjustDropDownSizeAndPosition();\n                    }\n                });\n    }\n\nint getSuggestionRowLayout() {\nreturn mSuggestionRowLayout;\n    }\n\nint getSuggestionCommitIconResId() {\nreturn mSuggestionCommitIconResId;\n    }\n\n\u002F**\n     * Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used\n     * to display labels, hints, suggestions, create intents for launching search results screens\n     * and controlling other affordances such as a voice button.\n     *\n     * @param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific\n     * activity or a global search provider.\n     *\u002F\n    public void setSearchableInfo(SearchableInfo searchable) {\nmSearchable = searchable;\n        if (mSearchable != null) {\n            updateSearchAutoComplete();\n            updateQueryHint();\n        }\n\u002F\u002F Cache the voice search capability\n        mVoiceButtonEnabled = hasVoiceSearch();\n\n        if (mVoiceButtonEnabled) {\n\u002F\u002F Disable the microphone on the keyboard, as a mic is displayed near the text box\n            \u002F\u002F TODO: use imeOptions to disable voice input when the new API will be available\n            mSearchSrcTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);\n        }\n        updateViewsVisibility(isIconified());\n    }\n\n\u002F**\n     * Sets the APP_DATA for legacy SearchDialog use.\n     * @param appSearchData bundle provided by the app when launching the search dialog\n     * @hide\n     *\u002F\n    public void setAppSearchData(Bundle appSearchData) {\nmAppSearchData = appSearchData;\n    }\n\n\u002F**\n     * Sets the IME options on the query text field.\n     *\n     * @see TextView#setImeOptions(int)\n     * @param imeOptions the options to set on the query text field\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_imeOptions\n     *\u002F\n    public void setImeOptions(int imeOptions) {\nmSearchSrcTextView.setImeOptions(imeOptions);\n    }\n\n\u002F**\n     * Returns the IME options set on the query text field.\n     * @return the ime options\n     * @see TextView#setImeOptions(int)\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_imeOptions\n     *\u002F\n    public int getImeOptions() {\nreturn mSearchSrcTextView.getImeOptions();\n    }\n\n\u002F**\n     * Sets the input type on the query text field.\n     *\n     * @see TextView#setInputType(int)\n     * @param inputType the input type to set on the query text field\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_inputType\n     *\u002F\n    public void setInputType(int inputType) {\nmSearchSrcTextView.setInputType(inputType);\n    }\n\n\u002F**\n     * Returns the input type set on the query text field.\n     * @return the input type\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_inputType\n     *\u002F\n    public int getInputType() {\nreturn mSearchSrcTextView.getInputType();\n    }\n\n\u002F** @hide *\u002F\n    @Override\n    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {\n\u002F\u002F Don't accept focus if in the middle of clearing focus\n        if (mClearingFocus) return false;\n        \u002F\u002F Check if SearchView is focusable.\n        if (!isFocusable()) return false;\n        \u002F\u002F If it is not iconified, then give the focus to the text field\n        if (!isIconified()) {\nboolean result = mSearchSrcTextView.requestFocus(direction, previouslyFocusedRect);\n            if (result) {\n                updateViewsVisibility(false);\n            }\nreturn result;\n        } else {\nreturn super.requestFocus(direction, previouslyFocusedRect);\n        }\n    }\n\n\u002F** @hide *\u002F\n    @Override\n    public void clearFocus() {\nmClearingFocus = true;\n        setImeVisibility(false);\n        super.clearFocus();\n        mSearchSrcTextView.clearFocus();\n        mClearingFocus = false;\n    }\n\n\u002F**\n     * Sets a listener for user actions within the SearchView.\n     *\n     * @param listener the listener object that receives callbacks when the user performs\n     * actions in the SearchView such as clicking on buttons or typing a query.\n     *\u002F\n    public void setOnQueryTextListener(OnQueryTextListener listener) {\nmOnQueryChangeListener = listener;\n    }\n\n\u002F**\n     * Sets a listener to inform when the user closes the SearchView.\n     *\n     * @param listener the listener to call when the user closes the SearchView.\n     *\u002F\n    public void setOnCloseListener(OnCloseListener listener) {\nmOnCloseListener = listener;\n    }\n\n\u002F**\n     * Sets a listener to inform when the focus of the query text field changes.\n     *\n     * @param listener the listener to inform of focus changes.\n     *\u002F\n    public void setOnQueryTextFocusChangeListener(OnFocusChangeListener listener) {\nmOnQueryTextFocusChangeListener = listener;\n    }\n\n\u002F**\n     * Sets a listener to inform when a suggestion is focused or clicked.\n     *\n     * @param listener the listener to inform of suggestion selection events.\n     *\u002F\n    public void setOnSuggestionListener(OnSuggestionListener listener) {\nmOnSuggestionListener = listener;\n    }\n\n\u002F**\n     * Sets a listener to inform when the search button is pressed. This is only\n     * relevant when the text field is not visible by default. Calling {@link #setIconified\n     * setIconified(false)} can also cause this listener to be informed.\n     *\n     * @param listener the listener to inform when the search button is clicked or\n     * the text field is programmatically de-iconified.\n     *\u002F\n    public void setOnSearchClickListener(OnClickListener listener) {\nmOnSearchClickListener = listener;\n    }\n\n\u002F**\n     * Returns the query string currently in the text field.\n     *\n     * @return the query string\n     *\u002F\n    public CharSequence getQuery() {\nreturn mSearchSrcTextView.getText();\n    }\n\n\u002F**\n     * Sets a query string in the text field and optionally submits the query as well.\n     *\n     * @param query the query string. This replaces any query text already present in the\n     * text field.\n     * @param submit whether to submit the query right now or only update the contents of\n     * text field.\n     *\u002F\n    public void setQuery(CharSequence query, boolean submit) {\nmSearchSrcTextView.setText(query);\n        if (query != null) {\nmSearchSrcTextView.setSelection(mSearchSrcTextView.length());\n            mUserQuery = query;\n        }\n\n\u002F\u002F If the query is not empty and submit is requested, submit the query\n        if (submit &amp;amp;&amp;amp; !TextUtils.isEmpty(query)) {\n            onSubmitQuery();\n        }\n    }\n\n\u002F**\n     * Sets the hint text to display in the query text field. This overrides\n     * any hint specified in the {@link SearchableInfo}.\n     * &amp;lt;p&amp;gt;\n     * This value may be specified as an empty string to prevent any query hint\n     * from being displayed.\n     *\n     * @param hint the hint text to display or {@code null} to clear\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_queryHint\n     *\u002F\n    public void setQueryHint(@Nullable CharSequence hint) {\nmQueryHint = hint;\n        updateQueryHint();\n    }\n\n\u002F**\n     * Returns the hint text that will be displayed in the query text field.\n     * &amp;lt;p&amp;gt;\n     * The displayed query hint is chosen in the following order:\n     * &amp;lt;ol&amp;gt;\n     * &amp;lt;li&amp;gt;Non-null value set with {@link #setQueryHint(CharSequence)}\n     * &amp;lt;li&amp;gt;Value specified in XML using {@code app:queryHint}\n     * &amp;lt;li&amp;gt;Valid string resource ID exposed by the {@link SearchableInfo} via\n     *     {@link SearchableInfo#getHintId()}\n     * &amp;lt;li&amp;gt;Default hint provided by the theme against which the view was\n     *     inflated\n     * &amp;lt;\u002Fol&amp;gt;\n     *\n     *\n     *\n     * @return the displayed query hint text, or {@code null} if none set\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_queryHint\n     *\u002F\n    @Nullable\n    public CharSequence getQueryHint() {\nfinal CharSequence hint;\n        if (mQueryHint != null) {\n            hint = mQueryHint;\n        } else if (mSearchable != null &amp;amp;&amp;amp; mSearchable.getHintId() != 0) {\n            hint = getContext().getText(mSearchable.getHintId());\n        } else {\n            hint = mDefaultQueryHint;\n        }\nreturn hint;\n    }\n\n\u002F**\n     * Sets the default or resting state of the search field. If true, a single search icon is\n     * shown by default and expands to show the text field and other buttons when pressed. Also,\n     * if the default state is iconified, then it collapses to that state when the close button\n     * is pressed. Changes to this property will take effect immediately.\n     *\n     * &amp;lt;p&amp;gt;The default value is true.&amp;lt;\u002Fp&amp;gt;\n     *\n     * @param iconified whether the search field should be iconified by default\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_iconifiedByDefault\n     *\u002F\n    public void setIconifiedByDefault(boolean iconified) {\nif (mIconifiedByDefault == iconified) return;\n        mIconifiedByDefault = iconified;\n        updateViewsVisibility(iconified);\n        updateQueryHint();\n    }\n\n\u002F**\n     * Returns the default iconified state of the search field.\n     * @return\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_iconifiedByDefault\n     *\u002F\n    public boolean isIconfiedByDefault() {\nreturn mIconifiedByDefault;\n    }\n\n\u002F**\n     * Iconifies or expands the SearchView. Any query text is cleared when iconified. This is\n     * a temporary state and does not override the default iconified state set by\n     * {@link #setIconifiedByDefault(boolean)}. If the default state is iconified, then\n     * a false here will only be valid until the user closes the field. And if the default\n     * state is expanded, then a true here will only clear the text field and not close it.\n     *\n     * @param iconify a true value will collapse the SearchView to an icon, while a false will\n     * expand it.\n     *\u002F\n    public void setIconified(boolean iconify) {\nif (iconify) {\n            onCloseClicked();\n        } else {\n            onSearchClicked();\n        }\n    }\n\n\u002F**\n     * Returns the current iconified state of the SearchView.\n     *\n     * @return true if the SearchView is currently iconified, false if the search field is\n     * fully visible.\n     *\u002F\n    public boolean isIconified() {\nreturn mIconified;\n    }\n\n\u002F**\n     * Enables showing a submit button when the query is non-empty. In cases where the SearchView\n     * is being used to filter the contents of the current activity and doesn't launch a separate\n     * results activity, then the submit button should be disabled.\n     *\n     * @param enabled true to show a submit button for submitting queries, false if a submit\n     * button is not required.\n     *\u002F\n    public void setSubmitButtonEnabled(boolean enabled) {\nmSubmitButtonEnabled = enabled;\n        updateViewsVisibility(isIconified());\n    }\n\n\u002F**\n     * Returns whether the submit button is enabled when necessary or never displayed.\n     *\n     * @return whether the submit button is enabled automatically when necessary\n     *\u002F\n    public boolean isSubmitButtonEnabled() {\nreturn mSubmitButtonEnabled;\n    }\n\n\u002F**\n     * Specifies if a query refinement button should be displayed alongside each suggestion\n     * or if it should depend on the flags set in the individual items retrieved from the\n     * suggestions provider. Clicking on the query refinement button will replace the text\n     * in the query text field with the text from the suggestion. This flag only takes effect\n     * if a SearchableInfo has been specified with {@link #setSearchableInfo(SearchableInfo)}\n     * and not when using a custom adapter.\n     *\n     * @param enable true if all items should have a query refinement button, false if only\n     * those items that have a query refinement flag set should have the button.\n     *\n     * @see SearchManager#SUGGEST_COLUMN_FLAGS\n     * @see SearchManager#FLAG_QUERY_REFINEMENT\n     *\u002F\n    public void setQueryRefinementEnabled(boolean enable) {\nmQueryRefinement = enable;\n        if (mSuggestionsAdapter instanceof SuggestionsAdapter) {\n            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(\n                    enable ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);\n        }\n    }\n\n\u002F**\n     * Returns whether query refinement is enabled for all items or only specific ones.\n     * @return true if enabled for all items, false otherwise.\n     *\u002F\n    public boolean isQueryRefinementEnabled() {\nreturn mQueryRefinement;\n    }\n\n\u002F**\n     * You can set a custom adapter if you wish. Otherwise the default adapter is used to\n     * display the suggestions from the suggestions provider associated with the SearchableInfo.\n     *\n     * @see #setSearchableInfo(SearchableInfo)\n     *\u002F\n    public void setSuggestionsAdapter(CursorAdapter adapter) {\nmSuggestionsAdapter = adapter;\n\n        mSearchSrcTextView.setAdapter(mSuggestionsAdapter);\n    }\n\n\u002F**\n     * Returns the adapter used for suggestions, if any.\n     * @return the suggestions adapter\n     *\u002F\n    public CursorAdapter getSuggestionsAdapter() {\nreturn mSuggestionsAdapter;\n    }\n\n\u002F**\n     * Makes the view at most this many pixels wide\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_maxWidth\n     *\u002F\n    public void setMaxWidth(int maxpixels) {\nmMaxWidth = maxpixels;\n\n        requestLayout();\n    }\n\n\u002F**\n     * Gets the specified maximum width in pixels, if set. Returns zero if\n     * no maximum width was specified.\n     * @return the maximum width of the view\n     *\n     * @attr ref android.support.v7.appcompat.R.styleable#SearchView_android_maxWidth\n     *\u002F\n    public int getMaxWidth() {\nreturn mMaxWidth;\n    }\n\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\u002F\u002F Let the standard measurements take effect in iconified state.\n        if (isIconified()) {\nsuper.onMeasure(widthMeasureSpec, heightMeasureSpec);\n            return;\n        }\n\nint widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int width = MeasureSpec.getSize(widthMeasureSpec);\n\n        switch (widthMode) {\ncase MeasureSpec.AT_MOST:\n\u002F\u002F If there is an upper limit, don't exceed maximum width (explicit or implicit)\n                if (mMaxWidth &amp;gt; 0) {\n                    width = Math.min(mMaxWidth, width);\n                } else {\n                    width = Math.min(getPreferredWidth(), width);\n                }\nbreak;\n            case MeasureSpec.EXACTLY:\n\u002F\u002F If an exact width is specified, still don't exceed any specified maximum width\n                if (mMaxWidth &amp;gt; 0) {\n                    width = Math.min(mMaxWidth, width);\n                }\nbreak;\n            case MeasureSpec.UNSPECIFIED:\n\u002F\u002F Use maximum width, if specified, else preferred width\n                width = mMaxWidth &amp;gt; 0 ? mMaxWidth : getPreferredWidth();\n                break;\n        }\n        widthMode = MeasureSpec.EXACTLY;\n\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        int height = MeasureSpec.getSize(heightMeasureSpec);\n\n        switch (heightMode) {\ncase MeasureSpec.AT_MOST:\ncase MeasureSpec.UNSPECIFIED:\n                height = Math.min(getPreferredHeight(), height);\n                break;\n        }\n        heightMode = MeasureSpec.EXACTLY;\n\n        super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode),\n                MeasureSpec.makeMeasureSpec(height, heightMode));\n    }\n\n@Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\nsuper.onLayout(changed, left, top, right, bottom);\n\n        if (changed) {\n\u002F\u002F Expand mSearchSrcTextView touch target to be the height of the parent in order to\n            \u002F\u002F allow it to be up to 48dp.\n            getChildBoundsWithinSearchView(mSearchSrcTextView, mSearchSrcTextViewBounds);\n            mSearchSrtTextViewBoundsExpanded.set(\nmSearchSrcTextViewBounds.left, 0, mSearchSrcTextViewBounds.right, bottom - top);\n            if (mTouchDelegate == null) {\nmTouchDelegate = new UpdatableTouchDelegate(mSearchSrtTextViewBoundsExpanded,\n                        mSearchSrcTextViewBounds, mSearchSrcTextView);\n                setTouchDelegate(mTouchDelegate);\n            } else {\nmTouchDelegate.setBounds(mSearchSrtTextViewBoundsExpanded, mSearchSrcTextViewBounds);\n            }\n        }\n    }\n\nprivate void getChildBoundsWithinSearchView(View view, Rect rect) {\n        view.getLocationInWindow(mTemp);\n        getLocationInWindow(mTemp2);\n        final int top = mTemp[1] - mTemp2[1];\n        final int left = mTemp[0] - mTemp2[0];\n        rect.set(left, top, left + view.getWidth(), top + view.getHeight());\n    }\n\nprivate int getPreferredWidth() {\nreturn getContext().getResources()\n                .getDimensionPixelSize(R.dimen.abc_search_view_preferred_width);\n    }\n\nprivate int getPreferredHeight() {\nreturn getContext().getResources()\n                .getDimensionPixelSize(R.dimen.abc_search_view_preferred_height);\n    }\n\nprivate void updateViewsVisibility(final boolean collapsed) {\nmIconified = collapsed;\n        \u002F\u002F Visibility of views that are visible when collapsed\n        final int visCollapsed = collapsed ? VISIBLE : GONE;\n        \u002F\u002F Is there text in the query\n        final boolean hasText = !TextUtils.isEmpty(mSearchSrcTextView.getText());\n\n        mSearchButton.setVisibility(visCollapsed);\n        updateSubmitButton(hasText);\n        mSearchEditFrame.setVisibility(collapsed ? GONE : VISIBLE);\n\n        final int iconVisibility;\n        if (mCollapsedIcon.getDrawable() == null || mIconifiedByDefault) {\n            iconVisibility = GONE;\n        } else {\n            iconVisibility = VISIBLE;\n        }\nmCollapsedIcon.setVisibility(iconVisibility);\n\n        updateCloseButton();\n        updateVoiceButton(!hasText);\n        updateSubmitArea();\n    }\n\nprivate boolean hasVoiceSearch() {\nif (mSearchable != null &amp;amp;&amp;amp; mSearchable.getVoiceSearchEnabled()) {\n            Intent testIntent = null;\n            if (mSearchable.getVoiceSearchLaunchWebSearch()) {\n                testIntent = mVoiceWebSearchIntent;\n            } else if (mSearchable.getVoiceSearchLaunchRecognizer()) {\n                testIntent = mVoiceAppSearchIntent;\n            }\nif (testIntent != null) {\n                ResolveInfo ri = getContext().getPackageManager().resolveActivity(testIntent,\n                        PackageManager.MATCH_DEFAULT_ONLY);\n                return ri != null;\n            }\n        }\nreturn false;\n    }\n\nprivate boolean isSubmitAreaEnabled() {\nreturn (mSubmitButtonEnabled || mVoiceButtonEnabled) &amp;amp;&amp;amp; !isIconified();\n    }\n\nprivate void updateSubmitButton(boolean hasText) {\nint visibility = GONE;\n        if (mSubmitButtonEnabled &amp;amp;&amp;amp; isSubmitAreaEnabled() &amp;amp;&amp;amp; hasFocus()\n                &amp;amp;&amp;amp; (hasText || !mVoiceButtonEnabled)) {\n            visibility = VISIBLE;\n        }\nmGoButton.setVisibility(visibility);\n    }\n\nprivate void updateSubmitArea() {\nint visibility = GONE;\n        if (isSubmitAreaEnabled()\n                &amp;amp;&amp;amp; (mGoButton.getVisibility() == VISIBLE\n                        || mVoiceButton.getVisibility() == VISIBLE)) {\n            visibility = VISIBLE;\n        }\nmSubmitArea.setVisibility(visibility);\n    }\n\nprivate void updateCloseButton() {\nfinal boolean hasText = !TextUtils.isEmpty(mSearchSrcTextView.getText());\n        \u002F\u002F Should we show the close button? It is not shown if there's no focus,\n        \u002F\u002F field is not iconified by default and there is no text in it.\n        final boolean showClose = hasText || (mIconifiedByDefault &amp;amp;&amp;amp; !mExpandedInActionView);\n        mCloseButton.setVisibility(showClose ? VISIBLE : GONE);\n        final Drawable closeButtonImg = mCloseButton.getDrawable();\n        if (closeButtonImg != null){\n            closeButtonImg.setState(hasText ? ENABLED_STATE_SET : EMPTY_STATE_SET);\n        }\n    }\n\nprivate void postUpdateFocusedState() {\n        post(mUpdateDrawableStateRunnable);\n    }\n\nprivate void updateFocusedState() {\nfinal boolean focused = mSearchSrcTextView.hasFocus();\n        final int[] stateSet = focused ? FOCUSED_STATE_SET : EMPTY_STATE_SET;\n        final Drawable searchPlateBg = mSearchPlate.getBackground();\n        if (searchPlateBg != null) {\n            searchPlateBg.setState(stateSet);\n        }\nfinal Drawable submitAreaBg = mSubmitArea.getBackground();\n        if (submitAreaBg != null) {\n            submitAreaBg.setState(stateSet);\n        }\n        invalidate();\n    }\n\n@Override\n    protected void onDetachedFromWindow() {\n        removeCallbacks(mUpdateDrawableStateRunnable);\n        post(mReleaseCursorRunnable);\n        super.onDetachedFromWindow();\n    }\n\nprivate void setImeVisibility(final boolean visible) {\nif (visible) {\n            post(mShowImeRunnable);\n        } else {\n            removeCallbacks(mShowImeRunnable);\n            InputMethodManager imm = (InputMethodManager)\n                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\n\n            if (imm != null) {\n                imm.hideSoftInputFromWindow(getWindowToken(), 0);\n            }\n        }\n    }\n\n\u002F**\n     * Called by the SuggestionsAdapter\n     * @hide\n     *\u002F\n    \u002F* package *\u002Fvoid onQueryRefine(CharSequence queryText) {\n        setQuery(queryText);\n    }\n\nprivate final OnClickListener mOnClickListener = new OnClickListener() {\n@Override\n        public void onClick(View v) {\nif (v == mSearchButton) {\n                onSearchClicked();\n            } else if (v == mCloseButton) {\n                onCloseClicked();\n            } else if (v == mGoButton) {\n                onSubmitQuery();\n            } else if (v == mVoiceButton) {\n                onVoiceClicked();\n            } else if (v == mSearchSrcTextView) {\n                forceSuggestionQuery();\n            }\n        }\n    };\n\n    \u002F**\n     * React to the user typing \"enter\" or other hardwired keys while typing in\n     * the search box. This handles these special keys while the edit box has\n     * focus.\n     *\u002F\n    View.OnKeyListener mTextKeyListener = new View.OnKeyListener() {\n@Override\n        public boolean onKey(View v, int keyCode, KeyEvent event) {\n\u002F\u002F guard against possible race conditions\n            if (mSearchable == null) {\nreturn false;\n            }\n\nif (DBG) {\n                Log.d(LOG_TAG, \"mTextListener.onKey(\" + keyCode + \",\" + event + \"), selection: \"\n                        + mSearchSrcTextView.getListSelection());\n            }\n\n\u002F\u002F If a suggestion is selected, handle enter, search key, and action keys\n            \u002F\u002F as presses on the selected suggestion\n            if (mSearchSrcTextView.isPopupShowing()\n                    &amp;amp;&amp;amp; mSearchSrcTextView.getListSelection() != ListView.INVALID_POSITION) {\nreturn onSuggestionsKey(v, keyCode, event);\n            }\n\n\u002F\u002F If there is text in the query box, handle enter, and action keys\n            \u002F\u002F The search key is handled by the dialog's onKeyDown().\n            if (!mSearchSrcTextView.isEmpty() &amp;amp;&amp;amp; KeyEventCompat.hasNoModifiers(event)) {\nif (event.getAction() == KeyEvent.ACTION_UP) {\nif (keyCode == KeyEvent.KEYCODE_ENTER) {\n                        v.cancelLongPress();\n\n                        \u002F\u002F Launch as a regular search.\n                        launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, mSearchSrcTextView.getText()\n                                .toString());\n                        return true;\n                    }\n                }\n            }\nreturn false;\n        }\n    };\n\n    \u002F**\n     * React to the user typing while in the suggestions list. First, check for\n     * action keys. If not handled, try refocusing regular characters into the\n     * EditText.\n     *\u002F\n    private boolean onSuggestionsKey(View v, int keyCode, KeyEvent event) {\n\u002F\u002F guard against possible race conditions (late arrival after dismiss)\n        if (mSearchable == null) {\nreturn false;\n        }\nif (mSuggestionsAdapter == null) {\nreturn false;\n        }\nif (event.getAction() == KeyEvent.ACTION_DOWN &amp;amp;&amp;amp; KeyEventCompat.hasNoModifiers(event)) {\n\u002F\u002F First, check for enter or search (both of which we'll treat as a\n            \u002F\u002F \"click\")\n            if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH\n                    || keyCode == KeyEvent.KEYCODE_TAB) {\nint position = mSearchSrcTextView.getListSelection();\n                return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);\n            }\n\n\u002F\u002F Next, check for left\u002Fright moves, which we use to \"return\" the\n            \u002F\u002F user to the edit view\n            if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {\n\u002F\u002F give \"focus\" to text editor, with cursor at the beginning if\n                \u002F\u002F left key, at end if right key\n                \u002F\u002F TODO: Reverse left\u002Fright for right-to-left languages, e.g.\n                \u002F\u002F Arabic\n                int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mSearchSrcTextView\n                        .length();\n                mSearchSrcTextView.setSelection(selPoint);\n                mSearchSrcTextView.setListSelection(0);\n                mSearchSrcTextView.clearListSelection();\n                HIDDEN_METHOD_INVOKER.ensureImeVisible(mSearchSrcTextView, true);\n\n                return true;\n            }\n\n\u002F\u002F Next, check for an \"up and out\" move\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP &amp;amp;&amp;amp; 0 == mSearchSrcTextView.getListSelection()) {\n\u002F\u002F TODO: restoreUserQuery();\n                \u002F\u002F let ACTV complete the move\n                return false;\n            }\n        }\nreturn false;\n    }\n\nprivate CharSequence getDecoratedHint(CharSequence hintText) {\n\u002F\u002F If the field is always expanded or we don't have a search hint icon,\n        \u002F\u002F then don't add the search icon to the hint.\n        if (!mIconifiedByDefault || mSearchHintIcon == null) {\nreturn hintText;\n        }\n\nfinal int textSize = (int) (mSearchSrcTextView.getTextSize() * 1.25);\n        mSearchHintIcon.setBounds(0, 0, textSize, textSize);\n\n        final SpannableStringBuilder ssb = new SpannableStringBuilder(\"   \");\n        ssb.setSpan(new ImageSpan(mSearchHintIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        ssb.append(hintText);\n        return ssb;\n    }\n\nprivate void updateQueryHint() {\nfinal CharSequence hint = getQueryHint();\n        mSearchSrcTextView.setHint(getDecoratedHint(hint == null ? \"\" : hint));\n    }\n\n\u002F**\n     * Updates the auto-complete text view.\n     *\u002F\n    private void updateSearchAutoComplete() {\nmSearchSrcTextView.setThreshold(mSearchable.getSuggestThreshold());\n        mSearchSrcTextView.setImeOptions(mSearchable.getImeOptions());\n        int inputType = mSearchable.getInputType();\n        \u002F\u002F We only touch this if the input type is set up for text (which it almost certainly\n        \u002F\u002F should be, in the case of search!)\n        if ((inputType &amp;amp; InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {\n\u002F\u002F The existence of a suggestions authority is the proxy for \"suggestions\n            \u002F\u002F are available here\"\n            inputType &amp;amp;= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;\n            if (mSearchable.getSuggestAuthority() != null) {\n                inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;\n                \u002F\u002F TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing\n                \u002F\u002F auto-completion based on its own semantics, which it will present to the user\n                \u002F\u002F as they type. This generally means that the input method should not show its\n                \u002F\u002F own candidates, and the spell checker should not be in action. The text editor\n                \u002F\u002F supplies its candidates by calling InputMethodManager.displayCompletions(),\n                \u002F\u002F which in turn will call InputMethodSession.displayCompletions().\n                inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;\n            }\n        }\nmSearchSrcTextView.setInputType(inputType);\n        if (mSuggestionsAdapter != null) {\nmSuggestionsAdapter.changeCursor(null);\n        }\n\u002F\u002F attach the suggestions adapter, if suggestions are available\n        \u002F\u002F The existence of a suggestions authority is the proxy for \"suggestions available here\"\n        if (mSearchable.getSuggestAuthority() != null) {\nmSuggestionsAdapter = new SuggestionsAdapter(getContext(),\n                    this, mSearchable, mOutsideDrawablesCache);\n            mSearchSrcTextView.setAdapter(mSuggestionsAdapter);\n            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(\nmQueryRefinement ? SuggestionsAdapter.REFINE_ALL\n                    : SuggestionsAdapter.REFINE_BY_ENTRY);\n        }\n    }\n\n\u002F**\n     * Update the visibility of the voice button.  There are actually two voice search modes,\n     * either of which will activate the button.\n     * @param empty whether the search query text field is empty. If it is, then the other\n     * criteria apply to make the voice button visible.\n     *\u002F\n    private void updateVoiceButton(boolean empty) {\nint visibility = GONE;\n        if (mVoiceButtonEnabled &amp;amp;&amp;amp; !isIconified() &amp;amp;&amp;amp; empty) {\n            visibility = VISIBLE;\n            mGoButton.setVisibility(GONE);\n        }\nmVoiceButton.setVisibility(visibility);\n    }\n\nprivate final OnEditorActionListener mOnEditorActionListener = new OnEditorActionListener() {\n\n\u002F**\n         * Called when the input method default action key is pressed.\n         *\u002F\n        @Override\n        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n            onSubmitQuery();\n            return true;\n        }\n    };\n\n    private void onTextChanged(CharSequence newText) {\n        CharSequence text = mSearchSrcTextView.getText();\n        mUserQuery = text;\n        boolean hasText = !TextUtils.isEmpty(text);\n        updateSubmitButton(hasText);\n        updateVoiceButton(!hasText);\n        updateCloseButton();\n        updateSubmitArea();\n        if (mOnQueryChangeListener != null &amp;amp;&amp;amp; !TextUtils.equals(newText, mOldQueryText)) {\nmOnQueryChangeListener.onQueryTextChange(newText.toString());\n        }\nmOldQueryText = newText.toString();\n    }\n\nprivate void onSubmitQuery() {\n        CharSequence query = mSearchSrcTextView.getText();\n        if (query != null &amp;amp;&amp;amp; TextUtils.getTrimmedLength(query) &amp;gt; 0) {\nif (mOnQueryChangeListener == null\n                    || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) {\nif (mSearchable != null) {\n                    launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString());\n                }\n                setImeVisibility(false);\n                dismissSuggestions();\n            }\n        }\n    }\n\nprivate void dismissSuggestions() {\nmSearchSrcTextView.dismissDropDown();\n    }\n\nprivate void onCloseClicked() {\n        CharSequence text = mSearchSrcTextView.getText();\n        if (TextUtils.isEmpty(text)) {\nif (mIconifiedByDefault) {\n\u002F\u002F If the app doesn't override the close behavior\n                if (mOnCloseListener == null || !mOnCloseListener.onClose()) {\n\u002F\u002F hide the keyboard and remove focus\n                    clearFocus();\n                    \u002F\u002F collapse the search field\n                    updateViewsVisibility(true);\n                }\n            }\n        } else {\nmSearchSrcTextView.setText(\"\");\n            mSearchSrcTextView.requestFocus();\n            setImeVisibility(true);\n        }\n\n    }\n\nprivate void onSearchClicked() {\n        updateViewsVisibility(false);\n        mSearchSrcTextView.requestFocus();\n        setImeVisibility(true);\n        if (mOnSearchClickListener != null) {\nmOnSearchClickListener.onClick(this);\n        }\n    }\n\nprivate void onVoiceClicked() {\n\u002F\u002F guard against possible race conditions\n        if (mSearchable == null) {\nreturn;\n        }\n        SearchableInfo searchable = mSearchable;\n        try {\nif (searchable.getVoiceSearchLaunchWebSearch()) {\n                Intent webSearchIntent = createVoiceWebSearchIntent(mVoiceWebSearchIntent,\n                        searchable);\n                getContext().startActivity(webSearchIntent);\n            } else if (searchable.getVoiceSearchLaunchRecognizer()) {\n                Intent appSearchIntent = createVoiceAppSearchIntent(mVoiceAppSearchIntent,\n                        searchable);\n                getContext().startActivity(appSearchIntent);\n            }\n        } catch (ActivityNotFoundException e) {\n\u002F\u002F Should not happen, since we check the availability of\n            \u002F\u002F voice search before showing the button. But just in case...\n            Log.w(LOG_TAG, \"Could not find voice search activity\");\n        }\n    }\n\nvoid onTextFocusChanged() {\n        updateViewsVisibility(isIconified());\n        \u002F\u002F Delayed update to make sure that the focus has settled down and window focus changes\n        \u002F\u002F don't affect it. A synchronous update was not working.\n        postUpdateFocusedState();\n        if (mSearchSrcTextView.hasFocus()) {\n            forceSuggestionQuery();\n        }\n    }\n\n@Override\n    public void onWindowFocusChanged(boolean hasWindowFocus) {\nsuper.onWindowFocusChanged(hasWindowFocus);\n\n        postUpdateFocusedState();\n    }\n\n\u002F**\n     * {@inheritDoc}\n     *\u002F\n    @Override\n    public void onActionViewCollapsed() {\n        setQuery(\"\", false);\n        clearFocus();\n        updateViewsVisibility(true);\n        mSearchSrcTextView.setImeOptions(mCollapsedImeOptions);\n        mExpandedInActionView = false;\n    }\n\n\u002F**\n     * {@inheritDoc}\n     *\u002F\n    @Override\n    public void onActionViewExpanded() {\nif (mExpandedInActionView) return;\n\n        mExpandedInActionView = true;\n        mCollapsedImeOptions = mSearchSrcTextView.getImeOptions();\n        mSearchSrcTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);\n        mSearchSrcTextView.setText(\"\");\n        setIconified(false);\n    }\n\nstatic class SavedState extends AbsSavedState {\nboolean isIconified;\n\n        SavedState(Parcelable superState) {\nsuper(superState);\n        }\n\npublic SavedState(Parcel source, ClassLoader loader) {\nsuper(source, loader);\n            isIconified = (Boolean) source.readValue(null);\n        }\n\n@Override\n        public void writeToParcel(Parcel dest, int flags) {\nsuper.writeToParcel(dest, flags);\n            dest.writeValue(isIconified);\n        }\n\n@Override\n        public String toString() {\nreturn \"SearchView.SavedState{\"\n                    + Integer.toHexString(System.identityHashCode(this))\n                    + \" isIconified=\" + isIconified + \"}\";\n        }\n\npublic static final Parcelable.Creator&amp;lt;SavedState&amp;gt; CREATOR = ParcelableCompat.newCreator(\nnew ParcelableCompatCreatorCallbacks&amp;lt;SavedState&amp;gt;() {\n@Override\n                    public SavedState createFromParcel(Parcel in, ClassLoader loader) {\nreturn new SavedState(in, loader);\n                    }\n\n@Override\n                    public SavedState[] newArray(int size) {\nreturn new SavedState[size];\n                    }\n                });\n    }\n\n@Override\n    protected Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState ss = new SavedState(superState);\n        ss.isIconified = isIconified();\n        return ss;\n    }\n\n@Override\n    protected void onRestoreInstanceState(Parcelable state) {\nif (!(state instanceof SavedState)) {\nsuper.onRestoreInstanceState(state);\n            return;\n        }\n        SavedState ss = (SavedState) state;\n        super.onRestoreInstanceState(ss.getSuperState());\n        updateViewsVisibility(ss.isIconified);\n        requestLayout();\n    }\n\nprivate void adjustDropDownSizeAndPosition() {\nif (mDropDownAnchor.getWidth() &amp;gt; 1) {\n            Resources res = getContext().getResources();\n            int anchorPadding = mSearchPlate.getPaddingLeft();\n            Rect dropDownPadding = new Rect();\n            final boolean isLayoutRtl = ViewUtils.isLayoutRtl(this);\n            int iconOffset = mIconifiedByDefault\n                    ? res.getDimensionPixelSize(R.dimen.abc_dropdownitem_icon_width)\n                    + res.getDimensionPixelSize(R.dimen.abc_dropdownitem_text_padding_left)\n                    : 0;\n            mSearchSrcTextView.getDropDownBackground().getPadding(dropDownPadding);\n            int offset;\n            if (isLayoutRtl) {\n                offset = - dropDownPadding.left;\n            } else {\n                offset = anchorPadding - (dropDownPadding.left + iconOffset);\n            }\nmSearchSrcTextView.setDropDownHorizontalOffset(offset);\n            final int width = mDropDownAnchor.getWidth() + dropDownPadding.left\n                    + dropDownPadding.right + iconOffset - anchorPadding;\n            mSearchSrcTextView.setDropDownWidth(width);\n        }\n    }\n\nprivate boolean onItemClicked(int position, int actionKey, String actionMsg) {\nif (mOnSuggestionListener == null\n                || !mOnSuggestionListener.onSuggestionClick(position)) {\n            launchSuggestion(position, KeyEvent.KEYCODE_UNKNOWN, null);\n            setImeVisibility(false);\n            dismissSuggestions();\n            return true;\n        }\nreturn false;\n    }\n\nprivate boolean onItemSelected(int position) {\nif (mOnSuggestionListener == null\n                || !mOnSuggestionListener.onSuggestionSelect(position)) {\n            rewriteQueryFromSuggestion(position);\n            return true;\n        }\nreturn false;\n    }\n\nprivate final OnItemClickListener mOnItemClickListener = new OnItemClickListener() {\n\n\u002F**\n         * Implements OnItemClickListener\n         *\u002F\n        @Override\n        public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {\nif (DBG) Log.d(LOG_TAG, \"onItemClick() position \" + position);\n            onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);\n        }\n    };\n\n    private final OnItemSelectedListener mOnItemSelectedListener = new OnItemSelectedListener() {\n\n\u002F**\n         * Implements OnItemSelectedListener\n         *\u002F\n        @Override\n        public void onItemSelected(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {\nif (DBG) Log.d(LOG_TAG, \"onItemSelected() position \" + position);\n            SearchView.this.onItemSelected(position);\n        }\n\n\u002F**\n         * Implements OnItemSelectedListener\n         *\u002F\n        @Override\n        public void onNothingSelected(AdapterView&amp;lt;?&amp;gt; parent) {\nif (DBG)\n                Log.d(LOG_TAG, \"onNothingSelected()\");\n        }\n    };\n\n    \u002F**\n     * Query rewriting.\n     *\u002F\n    private void rewriteQueryFromSuggestion(int position) {\n        CharSequence oldQuery = mSearchSrcTextView.getText();\n        Cursor c = mSuggestionsAdapter.getCursor();\n        if (c == null) {\nreturn;\n        }\nif (c.moveToPosition(position)) {\n\u002F\u002F Get the new query from the suggestion.\n            CharSequence newQuery = mSuggestionsAdapter.convertToString(c);\n            if (newQuery != null) {\n\u002F\u002F The suggestion rewrites the query.\n                \u002F\u002F Update the text field, without getting new suggestions.\n                setQuery(newQuery);\n            } else {\n\u002F\u002F The suggestion does not rewrite the query, restore the user's query.\n                setQuery(oldQuery);\n            }\n        } else {\n\u002F\u002F We got a bad position, restore the user's query.\n            setQuery(oldQuery);\n        }\n    }\n\n\u002F**\n     * Launches an intent based on a suggestion.\n     *\n     * @param position The index of the suggestion to create the intent from.\n     * @param actionKey The key code of the action key that was pressed,\n     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.\n     * @param actionMsg The message for the action key that was pressed,\n     *        or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt; if none.\n     * @return true if a successful launch, false if could not (e.g. bad position).\n     *\u002F\n    private boolean launchSuggestion(int position, int actionKey, String actionMsg) {\n        Cursor c = mSuggestionsAdapter.getCursor();\n        if ((c != null) &amp;amp;&amp;amp; c.moveToPosition(position)) {\n\n            Intent intent = createIntentFromSuggestion(c, actionKey, actionMsg);\n\n            \u002F\u002F launch the intent\n            launchIntent(intent);\n\n            return true;\n        }\nreturn false;\n    }\n\n\u002F**\n     * Launches an intent, including any special intent handling.\n     *\u002F\n    private void launchIntent(Intent intent) {\nif (intent == null) {\nreturn;\n        }\ntry {\n\u002F\u002F If the intent was created from a suggestion, it will always have an explicit\n            \u002F\u002F component here.\n            getContext().startActivity(intent);\n        } catch (RuntimeException ex) {\n            Log.e(LOG_TAG, \"Failed launch activity: \" + intent, ex);\n        }\n    }\n\n\u002F**\n     * Sets the text in the query box, without updating the suggestions.\n     *\u002F\n    private void setQuery(CharSequence query) {\nmSearchSrcTextView.setText(query);\n        \u002F\u002F Move the cursor to the end\n        mSearchSrcTextView.setSelection(TextUtils.isEmpty(query) ? 0 : query.length());\n    }\n\nprivate void launchQuerySearch(int actionKey, String actionMsg, String query) {\n        String action = Intent.ACTION_SEARCH;\n        Intent intent = createIntent(action, null, null, query, actionKey, actionMsg);\n        getContext().startActivity(intent);\n    }\n\n\u002F**\n     * Constructs an intent from the given information and the search dialog state.\n     *\n     * @param action Intent action.\n     * @param data Intent data, or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt;.\n     * @param extraData Data for {@link SearchManager#EXTRA_DATA_KEY} or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt;.\n     * @param query Intent query, or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt;.\n     * @param actionKey The key code of the action key that was pressed,\n     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.\n     * @param actionMsg The message for the action key that was pressed,\n     *        or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt; if none.\n     * @return The intent.\n     *\u002F\n    private Intent createIntent(String action, Uri data, String extraData, String query,\n            int actionKey, String actionMsg) {\n\u002F\u002F Now build the Intent\n        Intent intent = new Intent(action);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \u002F\u002F We need CLEAR_TOP to avoid reusing an old task that has other activities\n        \u002F\u002F on top of the one we want. We don't want to do this in in-app search though,\n        \u002F\u002F as it can be destructive to the activity stack.\n        if (data != null) {\n            intent.setData(data);\n        }\n        intent.putExtra(SearchManager.USER_QUERY, mUserQuery);\n        if (query != null) {\n            intent.putExtra(SearchManager.QUERY, query);\n        }\nif (extraData != null) {\n            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);\n        }\nif (mAppSearchData != null) {\n            intent.putExtra(SearchManager.APP_DATA, mAppSearchData);\n        }\nif (actionKey != KeyEvent.KEYCODE_UNKNOWN) {\n            intent.putExtra(SearchManager.ACTION_KEY, actionKey);\n            intent.putExtra(SearchManager.ACTION_MSG, actionMsg);\n        }\n        intent.setComponent(mSearchable.getSearchActivity());\n        return intent;\n    }\n\n\u002F**\n     * Create and return an Intent that can launch the voice search activity for web search.\n     *\u002F\n    private Intent createVoiceWebSearchIntent(Intent baseIntent, SearchableInfo searchable) {\n        Intent voiceIntent = new Intent(baseIntent);\n        ComponentName searchActivity = searchable.getSearchActivity();\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null\n                : searchActivity.flattenToShortString());\n        return voiceIntent;\n    }\n\n\u002F**\n     * Create and return an Intent that can launch the voice search activity, perform a specific\n     * voice transcription, and forward the results to the searchable activity.\n     *\n     * @param baseIntent The voice app search intent to start from\n     * @return A completely-configured intent ready to send to the voice search activity\n     *\u002F\n    private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {\n        ComponentName searchActivity = searchable.getSearchActivity();\n\n        \u002F\u002F create the necessary intent to set up a search-and-forward operation\n        \u002F\u002F in the voice search system.   We have to keep the bundle separate,\n        \u002F\u002F because it becomes immutable once it enters the PendingIntent\n        Intent queryIntent = new Intent(Intent.ACTION_SEARCH);\n        queryIntent.setComponent(searchActivity);\n        PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent,\n                PendingIntent.FLAG_ONE_SHOT);\n\n        \u002F\u002F Now set up the bundle that will be inserted into the pending intent\n        \u002F\u002F when it's time to do the search.  We always build it here (even if empty)\n        \u002F\u002F because the voice search activity will always need to insert \"QUERY\" into\n        \u002F\u002F it anyway.\n        Bundle queryExtras = new Bundle();\n        if (mAppSearchData != null) {\n            queryExtras.putParcelable(SearchManager.APP_DATA, mAppSearchData);\n        }\n\n\u002F\u002F Now build the intent to launch the voice search.  Add all necessary\n        \u002F\u002F extras to launch the voice recognizer, and then all the necessary extras\n        \u002F\u002F to forward the results to the searchable activity\n        Intent voiceIntent = new Intent(baseIntent);\n\n        \u002F\u002F Add all of the configuration options supplied by the searchable's metadata\n        String languageModel = RecognizerIntent.LANGUAGE_MODEL_FREE_FORM;\n        String prompt = null;\n        String language = null;\n        int maxResults = 1;\n\n        Resources resources = getResources();\n        if (searchable.getVoiceLanguageModeId() != 0) {\n            languageModel = resources.getString(searchable.getVoiceLanguageModeId());\n        }\nif (searchable.getVoicePromptTextId() != 0) {\n            prompt = resources.getString(searchable.getVoicePromptTextId());\n        }\nif (searchable.getVoiceLanguageId() != 0) {\n            language = resources.getString(searchable.getVoiceLanguageId());\n        }\nif (searchable.getVoiceMaxResults() != 0) {\n            maxResults = searchable.getVoiceMaxResults();\n        }\n\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, languageModel);\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, prompt);\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults);\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null\n                : searchActivity.flattenToShortString());\n\n        \u002F\u002F Add the values that configure forwarding the results\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT, pending);\n        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT_BUNDLE, queryExtras);\n\n        return voiceIntent;\n    }\n\n\u002F**\n     * When a particular suggestion has been selected, perform the various lookups required\n     * to use the suggestion.  This includes checking the cursor for suggestion-specific data,\n     * and\u002For falling back to the XML for defaults;  It also creates REST style Uri data when\n     * the suggestion includes a data id.\n     *\n     * @param c The suggestions cursor, moved to the row of the user's selection\n     * @param actionKey The key code of the action key that was pressed,\n     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.\n     * @param actionMsg The message for the action key that was pressed,\n     *        or &amp;lt;code&amp;gt;null&amp;lt;\u002Fcode&amp;gt; if none.\n     * @return An intent for the suggestion at the cursor's position.\n     *\u002F\n    private Intent createIntentFromSuggestion(Cursor c, int actionKey, String actionMsg) {\ntry {\n\u002F\u002F use specific action if supplied, or default action if supplied, or fixed default\n            String action = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_ACTION);\n\n            if (action == null) {\n                action = mSearchable.getSuggestIntentAction();\n            }\nif (action == null) {\n                action = Intent.ACTION_SEARCH;\n            }\n\n\u002F\u002F use specific data if supplied, or default data if supplied\n            String data = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA);\n            if (data == null) {\n                data = mSearchable.getSuggestIntentData();\n            }\n\u002F\u002F then, if an ID was provided, append it.\n            if (data != null) {\n                String id = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);\n                if (id != null) {\n                    data = data + \"\u002F\" + Uri.encode(id);\n                }\n            }\n            Uri dataUri = (data == null) ? null : Uri.parse(data);\n\n            String query = getColumnString(c, SearchManager.SUGGEST_COLUMN_QUERY);\n            String extraData = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);\n\n            return createIntent(action, dataUri, extraData, query, actionKey, actionMsg);\n        } catch (RuntimeException e ) {\nint rowNum;\n            try {                       \u002F\u002F be really paranoid now\n                rowNum = c.getPosition();\n            } catch (RuntimeException e2 ) {\n                rowNum = -1;\n            }\n            Log.w(LOG_TAG, \"Search suggestions cursor at row \" + rowNum +\n\" returned exception.\", e);\n            return null;\n        }\n    }\n\nprivate void forceSuggestionQuery() {\nHIDDEN_METHOD_INVOKER.doBeforeTextChanged(mSearchSrcTextView);\n        HIDDEN_METHOD_INVOKER.doAfterTextChanged(mSearchSrcTextView);\n    }\n\nstatic boolean isLandscapeMode(Context context) {\nreturn context.getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n    }\n\n\u002F**\n     * Callback to watch the text field for empty\u002Fnon-empty\n     *\u002F\n    private TextWatcher mTextWatcher = new TextWatcher() {\n@Override\n        public void beforeTextChanged(CharSequence s, int start, int before, int after) { }\n\n@Override\n        public void onTextChanged(CharSequence s, int start,\n                int before, int after) {\n            SearchView.this.onTextChanged(s);\n        }\n\n@Override\n        public void afterTextChanged(Editable s) {\n        }\n    };\n\n    private static class UpdatableTouchDelegate extends TouchDelegate {\n\u002F**\n         * View that should receive forwarded touch events\n         *\u002F\n        private final View mDelegateView;\n\n        \u002F**\n         * Bounds in local coordinates of the containing view that should be mapped to the delegate\n         * view. This rect is used for initial hit testing.\n         *\u002F\n        private final Rect mTargetBounds;\n\n        \u002F**\n         * Bounds in local coordinates of the containing view that are actual bounds of the delegate\n         * view. This rect is used for event coordinate mapping.\n         *\u002F\n        private final Rect mActualBounds;\n\n        \u002F**\n         * mTargetBounds inflated to include some slop. This rect is to track whether the motion events\n         * should be considered to be be within the delegate view.\n         *\u002F\n        private final Rect mSlopBounds;\n\n        private final int mSlop;\n\n        \u002F**\n         * True if the delegate had been targeted on a down event (intersected mTargetBounds).\n         *\u002F\n        private boolean mDelegateTargeted;\n\n        public UpdatableTouchDelegate(Rect targetBounds, Rect actualBounds, View delegateView) {\nsuper(targetBounds, delegateView);\n            mSlop = ViewConfiguration.get(delegateView.getContext()).getScaledTouchSlop();\n            mTargetBounds = new Rect();\n            mSlopBounds = new Rect();\n            mActualBounds = new Rect();\n            setBounds(targetBounds, actualBounds);\n            mDelegateView = delegateView;\n        }\n\npublic void setBounds(Rect desiredBounds, Rect actualBounds) {\nmTargetBounds.set(desiredBounds);\n            mSlopBounds.set(desiredBounds);\n            mSlopBounds.inset(-mSlop, -mSlop);\n            mActualBounds.set(actualBounds);\n        }\n\n@Override\n        public boolean onTouchEvent(MotionEvent event) {\nfinal int x = (int) event.getX();\n            final int y = (int) event.getY();\n            boolean sendToDelegate = false;\n            boolean hit = true;\n            boolean handled = false;\n\n            switch (event.getAction()) {\ncase MotionEvent.ACTION_DOWN:\nif (mTargetBounds.contains(x, y)) {\nmDelegateTargeted = true;\n                        sendToDelegate = true;\n                    }\nbreak;\n                case MotionEvent.ACTION_UP:\ncase MotionEvent.ACTION_MOVE:\n                    sendToDelegate = mDelegateTargeted;\n                    if (sendToDelegate) {\nif (!mSlopBounds.contains(x, y)) {\n                            hit = false;\n                        }\n                    }\nbreak;\n                case MotionEvent.ACTION_CANCEL:\n                    sendToDelegate = mDelegateTargeted;\n                    mDelegateTargeted = false;\n                    break;\n            }\nif (sendToDelegate) {\nif (hit &amp;amp;&amp;amp; !mActualBounds.contains(x, y)) {\n\u002F\u002F Offset event coordinates to be in the center of the target view since we\n                    \u002F\u002F are within the targetBounds, but not inside the actual bounds of\n                    \u002F\u002F mDelegateView\n                    event.setLocation(mDelegateView.getWidth() \u002F 2,\n                            mDelegateView.getHeight() \u002F 2);\n                } else {\n\u002F\u002F Offset event coordinates to the target view coordinates.\n                    event.setLocation(x - mActualBounds.left, y - mActualBounds.top);\n                }\n\n                handled = mDelegateView.dispatchTouchEvent(event);\n            }\nreturn handled;\n        }\n    }\n\n\u002F**\n     * Local subclass for AutoCompleteTextView.\n     * @hide\n     *\u002F\n    public static class SearchAutoComplete extends AppCompatAutoCompleteTextView {\n\nprivate int mThreshold;\n        private SearchView mSearchView;\n\n        public SearchAutoComplete(Context context) {\nthis(context, null);\n        }\n\npublic SearchAutoComplete(Context context, AttributeSet attrs) {\nthis(context, attrs, R.attr.autoCompleteTextViewStyle);\n        }\n\npublic SearchAutoComplete(Context context, AttributeSet attrs, int defStyle) {\nsuper(context, attrs, defStyle);\n            mThreshold = getThreshold();\n        }\n\n@Override\n        protected void onFinishInflate() {\nsuper.onFinishInflate();\n            DisplayMetrics metrics = getResources().getDisplayMetrics();\n            setMinWidth((int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                    getSearchViewTextMinWidthDp(), metrics));\n        }\n\nvoid setSearchView(SearchView searchView) {\nmSearchView = searchView;\n        }\n\n@Override\n        public void setThreshold(int threshold) {\nsuper.setThreshold(threshold);\n            mThreshold = threshold;\n        }\n\n\u002F**\n         * Returns true if the text field is empty, or contains only whitespace.\n         *\u002F\n        private boolean isEmpty() {\nreturn TextUtils.getTrimmedLength(getText()) == 0;\n        }\n\n\u002F**\n         * We override this method to avoid replacing the query box text when a\n         * suggestion is clicked.\n         *\u002F\n        @Override\n        protected void replaceText(CharSequence text) {\n        }\n\n\u002F**\n         * We override this method to avoid an extra onItemClick being called on\n         * the drop-down's OnItemClickListener by\n         * {@link AutoCompleteTextView#onKeyUp(int, KeyEvent)} when an item is\n         * clicked with the trackball.\n         *\u002F\n        @Override\n        public void performCompletion() {\n        }\n\n\u002F**\n         * We override this method to be sure and show the soft keyboard if\n         * appropriate when the TextView has focus.\n         *\u002F\n        @Override\n        public void onWindowFocusChanged(boolean hasWindowFocus) {\nsuper.onWindowFocusChanged(hasWindowFocus);\n\n            if (hasWindowFocus &amp;amp;&amp;amp; mSearchView.hasFocus() &amp;amp;&amp;amp; getVisibility() == VISIBLE) {\n                InputMethodManager inputManager = (InputMethodManager) getContext()\n                        .getSystemService(Context.INPUT_METHOD_SERVICE);\n                inputManager.showSoftInput(this, 0);\n                \u002F\u002F If in landscape mode, then make sure that\n                \u002F\u002F the ime is in front of the dropdown.\n                if (isLandscapeMode(getContext())) {\nHIDDEN_METHOD_INVOKER.ensureImeVisible(this, true);\n                }\n            }\n        }\n\n@Override\n        protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {\nsuper.onFocusChanged(focused, direction, previouslyFocusedRect);\n            mSearchView.onTextFocusChanged();\n        }\n\n\u002F**\n         * We override this method so that we can allow a threshold of zero,\n         * which ACTV does not.\n         *\u002F\n        @Override\n        public boolean enoughToFilter() {\nreturn mThreshold &amp;lt;= 0 || super.enoughToFilter();\n        }\n\n@Override\n        public boolean onKeyPreIme(int keyCode, KeyEvent event) {\nif (keyCode == KeyEvent.KEYCODE_BACK) {\n\u002F\u002F special case for the back key, we do not even try to send it\n                \u002F\u002F to the drop down list but instead, consume it immediately\n                if (event.getAction() == KeyEvent.ACTION_DOWN &amp;amp;&amp;amp; event.getRepeatCount() == 0) {\n                    KeyEvent.DispatcherState state = getKeyDispatcherState();\n                    if (state != null) {\n                        state.startTracking(event, this);\n                    }\nreturn true;\n                } else if (event.getAction() == KeyEvent.ACTION_UP) {\n                    KeyEvent.DispatcherState state = getKeyDispatcherState();\n                    if (state != null) {\n                        state.handleUpEvent(event);\n                    }\nif (event.isTracking() &amp;amp;&amp;amp; !event.isCanceled()) {\nmSearchView.clearFocus();\n                        mSearchView.setImeVisibility(false);\n                        return true;\n                    }\n                }\n            }\nreturn super.onKeyPreIme(keyCode, event);\n        }\n\n\u002F**\n         * Get minimum width of the search view text entry area.\n         *\u002F\n        private int getSearchViewTextMinWidthDp() {\nfinal Configuration config = getResources().getConfiguration();\n            final int widthDp = ConfigurationHelper.getScreenWidthDp(getResources());\n            final int heightDp = ConfigurationHelper.getScreenHeightDp(getResources());\n\n            if (widthDp &amp;gt;= 960 &amp;amp;&amp;amp; heightDp &amp;gt;= 720\n                    &amp;amp;&amp;amp; config.orientation == Configuration.ORIENTATION_LANDSCAPE) {\nreturn 256;\n            } else if (widthDp &amp;gt;= 600 || (widthDp &amp;gt;= 640 &amp;amp;&amp;amp; heightDp &amp;gt;= 480)) {\nreturn 192;\n            }\nreturn 160;\n        }\n    }\n\nprivate static class AutoCompleteTextViewReflector {\nprivate Method doBeforeTextChanged, doAfterTextChanged;\n        private Method ensureImeVisible;\n        private Method showSoftInputUnchecked;\n\n        AutoCompleteTextViewReflector() {\ntry {\ndoBeforeTextChanged = AutoCompleteTextView.class\n                        .getDeclaredMethod(\"doBeforeTextChanged\");\n                doBeforeTextChanged.setAccessible(true);\n            } catch (NoSuchMethodException e) {\n\u002F\u002F Ah well.\n            }\ntry {\ndoAfterTextChanged = AutoCompleteTextView.class\n                        .getDeclaredMethod(\"doAfterTextChanged\");\n                doAfterTextChanged.setAccessible(true);\n            } catch (NoSuchMethodException e) {\n\u002F\u002F Ah well.\n            }\ntry {\nensureImeVisible = AutoCompleteTextView.class\n                        .getMethod(\"ensureImeVisible\", boolean.class);\n                ensureImeVisible.setAccessible(true);\n            } catch (NoSuchMethodException e) {\n\u002F\u002F Ah well.\n            }\ntry {\nshowSoftInputUnchecked = InputMethodManager.class.getMethod(\n\"showSoftInputUnchecked\", int.class, ResultReceiver.class);\n                showSoftInputUnchecked.setAccessible(true);\n            } catch (NoSuchMethodException e) {\n\u002F\u002F Ah well.\n            }\n        }\n\nvoid doBeforeTextChanged(AutoCompleteTextView view) {\nif (doBeforeTextChanged != null) {\ntry {\ndoBeforeTextChanged.invoke(view);\n                } catch (Exception e) {\n                }\n            }\n        }\n\nvoid doAfterTextChanged(AutoCompleteTextView view) {\nif (doAfterTextChanged != null) {\ntry {\ndoAfterTextChanged.invoke(view);\n                } catch (Exception e) {\n                }\n            }\n        }\n\nvoid ensureImeVisible(AutoCompleteTextView view, boolean visible) {\nif (ensureImeVisible != null) {\ntry {\nensureImeVisible.invoke(view, visible);\n                } catch (Exception e) {\n                }\n            }\n        }\n\nvoid showSoftInputUnchecked(InputMethodManager imm, View view, int flags) {\nif (showSoftInputUnchecked != null) {\ntry {\nshowSoftInputUnchecked.invoke(imm, flags, null);\n                    return;\n                } catch (Exception e) {\n                }\n            }\n\n\u002F\u002F Hidden method failed, call public version instead\n            imm.showSoftInput(view, flags);\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003Cb\u003EEnd\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u003Cb\u003E希望大家关注我的知乎，和个人github\u002Fqydq ，转载标明出处，谢谢。\u003C\u002Fb\u003E\u003C\u002Fp\u003E","updated":new Date("2016-09-10T02:28:20.000Z"),"canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":1,"state":"published","isLiked":false,"slug":"22388833","isTitleImageFullScreen":false,"rating":"none","titleImage":"https:\u002F\u002Fpic4.zhimg.com\u002Fb7153a2776958d2529f8429401e533ad_r.jpg","links":{"comments":"\u002Fapi\u002Fposts\u002F22388833\u002Fcomments"},"reviewers":[],"topics":[{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19555634","id":"19555634","name":"Android 开发"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F20005114","id":"20005114","name":"Material Design"}],"adminClosedComment":false,"titleImageSize":{"width":512,"height":334},"href":"\u002Fapi\u002Fposts\u002F22388833","excerptTitle":"","column":{"slug":"qyddai","name":"Android开发"},"tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":0,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2016-09-10T10:28:20+08:00","url":"\u002Fp\u002F22388833","lastestLikers":[{"bio":"Android 攻城狮","isFollowing":false,"hash":"6ae69fd6526d6097103bc3459804c6bf","uid":54507744526336,"isOrg":false,"slug":"mylhyz","isFollowed":false,"description":"Android 开发","name":"mylhyz","profileUrl":"https:\u002F\u002Fwww.zhihu.com\u002Fpeople\u002Fmylhyz","avatar":{"id":"8315ba69e42d71b923528de886466418","template":"https:\u002F\u002Fpic1.zhimg.com\u002F{id}_{size}.jpg"},"isOrgWhiteList":false,"isBanned":false}],"summary":"\u003Cb\u003EBegin\u003C\u002Fb\u003E末尾附上SearchView的源代码。 SearchView是google在v7后面引入的一个搜索的控件，今天不是第一次使用这个控件了，很早之前实现SeachView的办法是自定义View，既然android官方网站已经给出了这个View我们就没有再去自定义SeachView了。SearchView包含…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https:\u002F\u002Fpic4.zhimg.com\u002F50\u002Fb7153a2776958d2529f8429401e533ad_xl.jpg","links":{"comments":"\u002Fapi\u002Fposts\u002F22362839\u002Fcomments"},"topics":[{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19555634","id":"19555634","name":"Android 开发"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19551557","id":"19551557","name":"设计"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19566035","id":"19566035","name":"GitHub"}],"adminClosedComment":false,"href":"\u002Fapi\u002Fposts\u002F22362839","excerptTitle":"","author":{"bio":"即时通讯，软件设计与开发者，物联网，移动互联网，AIVRVI兴趣者","isFollowing":false,"hash":"071d1fea34ab3dc8850d9aa78d844fdb","uid":664439680704057300,"isOrg":false,"slug":"qydq","isFollowed":false,"description":"专注于物联网领域，世界的通信标准从今开始改变，手机也可以是路由器，成功于视频直播,标准并不一定是Http\u002Fs，也可以是Bluetooth。","name":"Bgwan","profileUrl":"https:\u002F\u002Fwww.zhihu.com\u002Fpeople\u002Fqydq","avatar":{"id":"464372bfcc3e304100f3cad266280fd5","template":"https:\u002F\u002Fpic2.zhimg.com\u002F{id}_{size}.jpg"},"isOrgWhiteList":false,"isBanned":false},"column":{"slug":"qyddai","name":"Android开发"},"content":"\u003Cp\u003E标题的图片盗用google+ 上面 Ankita Narayan美女的； 附上地址她的主页，外国人应该不太用知乎这种来交流吧。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fplus.google.com\u002F100907098925781574510\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E\u003Cspan class=\"invisible\"\u003Ehttps:\u002F\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"visible\"\u003Eplus.google.com\u002F1009070\u003C\u002Fspan\u003E\u003Cspan class=\"invisible\"\u003E98925781574510\u003C\u002Fspan\u003E\u003Cspan class=\"ellipsis\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003EBeging\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E# aw-RecyclerView 先看一下效果图吧\u003C\u002Fp\u003E\u003Cfigure\u003E\u003Cimg src=\"http:\u002F\u002Fpic3.zhimg.com\u002Fe7cc0733e636e9716b4b5a33c104e5a6_b.jpg\" data-rawwidth=\"720\" data-rawheight=\"1280\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"http:\u002F\u002Fpic3.zhimg.com\u002Fe7cc0733e636e9716b4b5a33c104e5a6_r.jpg\"\u003E\u003C\u002Ffigure\u003E\u003Cbr\u003E\u003Cp\u003EThis is aw project about how to setting background in android operator system in java code\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## **************源码在最后 。请大家多多关注 。**************##\u003C\u002Fp\u003E\u003Cp\u003EAthor：sunshuntao（qydq）。\u003C\u002Fp\u003E\u003Cp\u003EEmail：qyddai@gmail.com。\u003C\u002Fp\u003E\u003Cp\u003E知乎地址：\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fqyddai\" class=\"internal\"\u003EAndroid开发 - 知乎专栏\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## 特别说明\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    在github上更新代码，不要更新无用的代码，应该做到每一份代码做好相应的README.md，README.md必须要有该项目的功能，再上传至github上面。该awNightDay项目为以后上传项目时的一个参考项目，格式严格按照这个标准去实现。下面列出上传项目必要的规范\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\t时间说明：\u003C\u002Fp\u003E\u003Cp\u003E\t创建时间：2016年08月29日;最近修改时间：2016年08月30日。\u003C\u002Fp\u003E\u003Cp\u003E\tTips \u003C\u002Fp\u003E\u003Cp\u003E1。前言（包含该项目主要实现的功能的简短说明，运行配置；可选）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E2。实现效果（如果没有可以省略，但是建议要包含，因为项目以后自己看到的时候会帮助自己理解）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E3。思路或步骤（代码）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E4。重要知识点（总结，思考）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E5。内容参考（尊重原创）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E6。联系作者。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## -----------------------------woshifengexian------------------------------------##\u003C\u002Fp\u003E\u003Cp\u003E创建时间：2016年09月08日;最近修改时间：2016年09月08日。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\tTips ： null\u003C\u002Fp\u003E\u003Cp\u003E## -----------------------------woshifengexian------------------------------------##\t\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## 前言\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E******************github不应该介绍这么详细，决定今后更博的情况，以个人知乎为详细的讲解（简书不用了），github作为代码仓库简单介绍。***********\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E****************** 个人知乎主页\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fqydda\" class=\"internal\"\u003E没有找到该页面 - 知乎专栏\u003C\u002Fa\u003E 请大家多多支持  *************************************************************\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E   话说RecyclerView已经面市很久，也在很多应用中得到广泛的使用，在整个开发者圈子里面也拥有很不错的口碑，那说明RecyclerView拥有比ListView,GridView之类控件有很多的优点，例如:数据绑定，Item View创建,View的回收以及重用等机制。\u003C\u002Fp\u003E\u003Cp\u003E用了这么久，今天也开始封装这个类，在封装的时候写一个demo出来给大家参考一起进步。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E该项目主要实现MD RecyclerView 的新功能。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E1。RecyclerView+SwpieRefreshLayout实现下拉刷新效果:下拉刷新的功能。（自带技能）\u003C\u002Fp\u003E\u003Cp\u003E2。实现了ItemView的监听。（View.OnClickListener）\u003C\u002Fp\u003E\u003Cp\u003E3。RecyclerView设置滚动事件加入上拉加载更多功能。（RefreshRecyclerAdater）\u003C\u002Fp\u003E\u003Cp\u003E4。升级RecyclerView加入FootView实现上拉加载。（RefreshFootAdapter）\u003C\u002Fp\u003E\u003Cp\u003E5。普通RecyclerView的使用。（MainRecyclerviewAdapter）\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E项目配置《分别导入不同的Adapter括号后面的Adapter既可以实现上面五点分别对应的功能，也可以下载源码）\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E下面会对重要的类和知识点进行讲解。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Eexample 引用列子：\u003C\u002Fp\u003E\u003Cp\u003E## 实现效果\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E这里说明一下：\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E再显示数据的时候，需要添加下面的代码。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u002F\u002F设置swipeRefreshLayout颜色，android系统提供可以设置4中。\u003C\u002Fp\u003E\u003Cp\u003E        swipeRefreshLayout.setProgressBackgroundColorSchemeResource(android.R.color.white);\u003C\u002Fp\u003E\u003Cp\u003E        swipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_light,\u003C\u002Fp\u003E\u003Cp\u003E                android.R.color.holo_red_light, android.R.color.holo_orange_light,\u003C\u002Fp\u003E\u003Cp\u003E                android.R.color.holo_green_light);\u003C\u002Fp\u003E\u003Cp\u003E        swipeRefreshLayout.setProgressViewOffset(false, 0, (int) TypedValue\u003C\u002Fp\u003E\u003Cp\u003E                .applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, getResources()\u003C\u002Fp\u003E\u003Cp\u003E                        .getDisplayMetrics()));\u003C\u002Fp\u003E\u003Cp\u003E        linearLayoutManager = new LinearLayoutManager(this);\u003C\u002Fp\u003E\u003Cp\u003E        linearLayoutManager.setOrientation(OrientationHelper.VERTICAL);\u003C\u002Fp\u003E\u003Cp\u003E        mRecyclerView.setLayoutManager(linearLayoutManager);\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F添加自定义颜色高度的分隔线\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F        mRecyclerView.addItemDecoration(new DRecycleViewDivider(this, LinearLayoutManager.VERTICAL, 10, getResources().getColor(R.color.CommColorLine)));\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F添加自定义drawable的分隔线\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F        mRecyclerView.addItemDecoration(new DRecycleViewDivider(this, LinearLayoutManager.VERTICAL, R.drawable.aar_qrcode_scan_line));\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F添加系统默认的分隔线\u003C\u002Fp\u003E\u003Cp\u003E        mRecyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.VERTICAL));\u003C\u002Fp\u003E\u003Cp\u003E        adapter = new RefreshFootAdapter(this);\u003C\u002Fp\u003E\u003Cp\u003E        mRecyclerView.setAdapter(adapter);\u003C\u002Fp\u003E\u003Cp\u003E效果图 ：--&amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E| ![](\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fgithub.com\u002Fqydq\u002FawNightDay\u002Fblob\u002Fmaster\u002Fscreenpic\u002FREADME.md.gif\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003EawNightDay\u002FREADME.md.gif at master · qydq\u002FawNightDay · GitHub\u003C\u002Fa\u003E)| \u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## 思路和步骤。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E1。SwipeRefrshLayout是Google官方更新的一个Widget,可以实现下拉刷新的效果。该控件集成自ViewGroup在support-v4兼容包下，不过我们需要升级supportlibrary的版本到19.1以上。基本使用的方法如下:\u003C\u002Fp\u003E\u003Cp\u003EsetOnRefreshListener(OnRefreshListener):添加下拉刷新监听器\u003C\u002Fp\u003E\u003Cp\u003EsetRefreshing(boolean):显示或者隐藏刷新进度条\u003C\u002Fp\u003E\u003Cp\u003EisRefreshing():检查是否处于刷新状态\u003C\u002Fp\u003E\u003Cp\u003EsetColorSchemeResources():设置进度条的颜色主题，最多设置四种，setColorScheme()方法已经弃用了。\u003C\u002Fp\u003E\u003Cp\u003E如上面说明的需要添加的代码。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E2。SwipeRefreshLayout本身自带下拉刷新的效果，那么我们可以选择在RecyclerView布局外部嵌套一层SwipeRefreshLayout布局即可。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E&amp;lt;android.support.v4.widget.SwipeRefreshLayout\u003C\u002Fp\u003E\u003Cp\u003E        android:id=\"@+id\u002FswipeRefreshLayout\"\u003C\u002Fp\u003E\u003Cp\u003E        android:layout_width=\"match_parent\"\u003C\u002Fp\u003E\u003Cp\u003E        android:layout_height=\"match_parent\"\u003C\u002Fp\u003E\u003Cp\u003E        android:scrollbars=\"vertical\"&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E        &amp;lt;!-- cacheColorHint：系统默认拖动过程中列表背景是黑的,设置为透明 --&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E        &amp;lt;android.support.v7.widget.RecyclerView\u003C\u002Fp\u003E\u003Cp\u003E            android:id=\"@+id\u002Frecycler_view\"\u003C\u002Fp\u003E\u003Cp\u003E            android:layout_width=\"match_parent\"\u003C\u002Fp\u003E\u003Cp\u003E            android:layout_height=\"match_parent\"\u003C\u002Fp\u003E\u003Cp\u003E            android:overScrollMode=\"never\" \u002F&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E    &amp;lt;\u002Fandroid.support.v4.widget.SwipeRefreshLayout&amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E3。接着在Activity中获取SwipeRefreshLayout控件并且设置OnRefreshListener监听器，同时实现里边的onRefresh()方法，在该方法中进行网络请求最新数据，然后刷新RecyclerView列表同时设置SwipeRefreshLayout的进度Bar的隐藏或者显示效果。具体代码如下。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u002F\u002F mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            @Override\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                super.onScrollStateChanged(recyclerView, newState);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;amp;&amp;amp; lastVisibleItem + 1 == adapter.getItemCount()) {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                    adapter.changeMoreStatus(RefreshFootAdapter.LOADING_MORE);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                    new Handler().postDelayed(new Runnable() {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                        @Override\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                        public void run() {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                            List&amp;lt;String&amp;gt; newDatas = new ArrayList&amp;lt;String&amp;gt;();\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                            for (int i = 0; i &amp;lt; 5; i++) {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                                int index = i + 1;\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                                newDatas.add(\"more item\" + index);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                            }\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                            adapter.addMoreItem(newDatas, RefreshFootAdapter.PULLUP_LOAD_MORE);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                        }\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                    }, 2500);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                }\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            }\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            @Override\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                super.onScrolled(recyclerView, dx, dy);\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F                lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition();\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F            }\u003C\u002Fp\u003E\u003Cp\u003E\u002F\u002F        });\u003C\u002Fp\u003E\u003Cp\u003E4。Java代码。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E因为有四种Adapter的实现方式，这里只贴出所有的注释，下面给出RefreshFootAdapter的完整代码，并进行分析。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E1）RefreshRecyclerAdater\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u002F**********************************************************\u003C\u002Fp\u003E\u003Cp\u003E * @文件名称：RefreshRecyclerAdater\u003C\u002Fp\u003E\u003Cp\u003E * @文件作者：孙顺涛\u003C\u002Fp\u003E\u003Cp\u003E * @Email：staryumou@163.com邮箱已改qyddai@gmail.com\u003C\u002Fp\u003E\u003Cp\u003E * @创建时间：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E * @文件描述：该类实现了Recyclerview上拉刷新下拉加载贡多的功能，但是没有FooterView。\u003C\u002Fp\u003E\u003Cp\u003E * @修改历史：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E **********************************************************\u002F\u003C\u002Fp\u003E\u003Cp\u003E 代码里面已经备注的很详细了。\u003C\u002Fp\u003E\u003Cp\u003E2）RefreshFootAdapter实现思路和步骤。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Ea.getItemType(),这个就和ListView的Adapter的实现差不多了，那么我们这边可以使用多套布局给RecyclerView加入一个FootView布局即可。\u003C\u002Fp\u003E\u003Cp\u003ERefreshFootAdapter.java具体实现流程如下: 加入布局状态标志-用来判断此时加载是普通Item还是foot view。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Eb.重写getItemCount()方法,返回的Item数量在数据的基础上面+1，增加一项FootView布局项。\u003C\u002Fp\u003E\u003Cp\u003Epublic intgetItemCount() {\u003C\u002Fp\u003E\u003Cp\u003E        return mTitles.size()+1;\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Ec.重写getItemViewType方法来判断返回加载的布局的类型.\u003C\u002Fp\u003E\u003Cp\u003Epublic int getItemViewType(int position) {\u003C\u002Fp\u003E\u003Cp\u003E    \u002F\u002F 最后一个item设置为footerView\u003C\u002Fp\u003E\u003Cp\u003E    if (position + 1 == getItemCount()) {\u003C\u002Fp\u003E\u003Cp\u003E                return TYPE_FOOTER;\u003C\u002Fp\u003E\u003Cp\u003E            } else {\u003C\u002Fp\u003E\u003Cp\u003E                return TYPE_ITEM;\u003C\u002Fp\u003E\u003Cp\u003E            }\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003Ed.接着onCreateViewHolder(ViewGroup parent,int viewType)加载布局的时候根据viewType的类型来选择指定的布局创建，返回即可。\u003C\u002Fp\u003E\u003Cp\u003Epublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F进行判断显示类型，来创建返回不同的View\u003C\u002Fp\u003E\u003Cp\u003E        if(viewType==TYPE_ITEM){\u003C\u002Fp\u003E\u003Cp\u003E            Viewview=mInflater.inflate(R.layout.item_recycler_layout,parent,false);\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002F这边可以做一些属性设置，甚至事件监听绑定\u003C\u002Fp\u003E\u003Cp\u003E           \u002F\u002Fview.setBackgroundColor(Color.RED);\u003C\u002Fp\u003E\u003Cp\u003E            ItemViewHolder itemViewHolder=new ItemViewHolder(view);\u003C\u002Fp\u003E\u003Cp\u003E            return itemViewHolder;\u003C\u002Fp\u003E\u003Cp\u003E        }else if(viewType==TYPE_FOOTER){\u003C\u002Fp\u003E\u003Cp\u003E            Viewfoot_view=mInflater.inflate(R.layout.recycler_load_more_layout,parent,false);\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002F这边可以做一些属性设置，甚至事件监听绑定\u003C\u002Fp\u003E\u003Cp\u003E           \u002F\u002Fview.setBackgroundColor(Color.RED);\u003C\u002Fp\u003E\u003Cp\u003E            FootViewHolder footViewHolder=new FootViewHolder(foot_view);\u003C\u002Fp\u003E\u003Cp\u003E            return footViewHolder;\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E       return null;\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Ee.最后进行判断数据的时候(onBindViewHolder)，判断holder的类型来进行判定数据即可。\u003C\u002Fp\u003E\u003Cp\u003Epublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\u003C\u002Fp\u003E\u003Cp\u003E        if(holder instanceof ItemViewHolder) {\u003C\u002Fp\u003E\u003Cp\u003E           ((ItemViewHolder)holder).item_tv.setText(mTitles.get(position));\u003C\u002Fp\u003E\u003Cp\u003E            holder.itemView.setTag(position);\u003C\u002Fp\u003E\u003Cp\u003E        }else if(holder instanceof FootViewHolder){\u003C\u002Fp\u003E\u003Cp\u003E            FootViewHolderfootViewHolder=(FootViewHolder)holder;\u003C\u002Fp\u003E\u003Cp\u003E            switch (load_more_status){\u003C\u002Fp\u003E\u003Cp\u003E                case PULLUP_LOAD_MORE:\u003C\u002Fp\u003E\u003Cp\u003E                   footViewHolder.foot_view_item_tv.setText(\"上拉加载更多...\");\u003C\u002Fp\u003E\u003Cp\u003E                    break;\u003C\u002Fp\u003E\u003Cp\u003E                case LOADING_MORE:\u003C\u002Fp\u003E\u003Cp\u003E                   footViewHolder.foot_view_item_tv.setText(\"正在加载更多数据...\");\u003C\u002Fp\u003E\u003Cp\u003E                    break;\u003C\u002Fp\u003E\u003Cp\u003E            }\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cp\u003E类的完整代码，如下：\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E说明：private static final int TYPE_ITEM =0;  \u002F\u002F普通Item View \u003C\u002Fp\u003E\u003Cp\u003E   private static final intTYPE_FOOTER = 1;  \u002F\u002F顶部FootView \u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u002F**********************************************************\u003C\u002Fp\u003E\u003Cp\u003E * @文件名称：RefreshFootAdapter\u003C\u002Fp\u003E\u003Cp\u003E * @文件作者：孙顺涛\u003C\u002Fp\u003E\u003Cp\u003E * @Email：staryumou@163.com邮箱已改qyddai@gmail.com\u003C\u002Fp\u003E\u003Cp\u003E * @创建时间：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E * @文件描述：该Adapter实现上拉加载和下拉刷新的功能（自定义了FooterView布局）\u003C\u002Fp\u003E\u003Cp\u003E * @修改历史：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E **********************************************************\u002F\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Epublic class RefreshFootAdapter extends RecyclerView.Adapter&amp;lt;RecyclerView.ViewHolder&amp;gt; {\u003C\u002Fp\u003E\u003Cp\u003E    \u002F\u002F上拉加载更多\u003C\u002Fp\u003E\u003Cp\u003E    public static final int PULLUP_LOAD_MORE = 0;\u003C\u002Fp\u003E\u003Cp\u003E    \u002F\u002F正在加载中\u003C\u002Fp\u003E\u003Cp\u003E    public static final int LOADING_MORE = 1;\u003C\u002Fp\u003E\u003Cp\u003E    \u002F\u002F上拉加载更多状态-默认为0\u003C\u002Fp\u003E\u003Cp\u003E    private int load_more_status = 0;\u003C\u002Fp\u003E\u003Cp\u003E    private LayoutInflater mInflater;\u003C\u002Fp\u003E\u003Cp\u003E    private List&amp;lt;String&amp;gt; mTitles = null;\u003C\u002Fp\u003E\u003Cp\u003E    private static final int TYPE_ITEM = 0;  \u002F\u002F普通Item View\u003C\u002Fp\u003E\u003Cp\u003E    private static final int TYPE_FOOTER = 1;  \u002F\u002F顶部FootView\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    public RefreshFootAdapter(Context context) {\u003C\u002Fp\u003E\u003Cp\u003E        this.mInflater = LayoutInflater.from(context);\u003C\u002Fp\u003E\u003Cp\u003E        this.mTitles = new ArrayList&amp;lt;String&amp;gt;();\u003C\u002Fp\u003E\u003Cp\u003E        for (int i = 0; i &amp;lt; 20; i++) {\u003C\u002Fp\u003E\u003Cp\u003E            int index = i + 1;\u003C\u002Fp\u003E\u003Cp\u003E            mTitles.add(\"item\" + index);\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F**\u003C\u002Fp\u003E\u003Cp\u003E     * item显示类型\u003C\u002Fp\u003E\u003Cp\u003E     *\u003C\u002Fp\u003E\u003Cp\u003E     * @param parent\u003C\u002Fp\u003E\u003Cp\u003E     * @param viewType\u003C\u002Fp\u003E\u003Cp\u003E     * @return\u003C\u002Fp\u003E\u003Cp\u003E     *\u002F\u003C\u002Fp\u003E\u003Cp\u003E    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F进行判断显示类型，来创建返回不同的View\u003C\u002Fp\u003E\u003Cp\u003E        if (viewType == TYPE_ITEM) {\u003C\u002Fp\u003E\u003Cp\u003E            View view = mInflater.inflate(R.layout.aar_item_recycler_adapter_footview, parent, false);\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002F这边可以做一些属性设置，甚至事件监听绑定\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002Fview.setBackgroundColor(Color.RED);\u003C\u002Fp\u003E\u003Cp\u003E            ItemViewHolder itemViewHolder = new ItemViewHolder(view);\u003C\u002Fp\u003E\u003Cp\u003E            return itemViewHolder;\u003C\u002Fp\u003E\u003Cp\u003E        } else if (viewType == TYPE_FOOTER) {\u003C\u002Fp\u003E\u003Cp\u003E            View foot_view = mInflater.inflate(R.layout.aar_item_recycler_loadmore, parent, false);\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002F这边可以做一些属性设置，甚至事件监听绑定\u003C\u002Fp\u003E\u003Cp\u003E            \u002F\u002Fview.setBackgroundColor(Color.RED);\u003C\u002Fp\u003E\u003Cp\u003E            FootViewHolder footViewHolder = new FootViewHolder(foot_view);\u003C\u002Fp\u003E\u003Cp\u003E            return footViewHolder;\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E        return null;\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F**\u003C\u002Fp\u003E\u003Cp\u003E     * 数据的绑定显示\u003C\u002Fp\u003E\u003Cp\u003E     *\u003C\u002Fp\u003E\u003Cp\u003E     * @param holder\u003C\u002Fp\u003E\u003Cp\u003E     * @param position\u003C\u002Fp\u003E\u003Cp\u003E     *\u002F\u003C\u002Fp\u003E\u003Cp\u003E    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\u003C\u002Fp\u003E\u003Cp\u003E        if (holder instanceof ItemViewHolder) {\u003C\u002Fp\u003E\u003Cp\u003E            ((ItemViewHolder) holder).item_tv.setText(mTitles.get(position));\u003C\u002Fp\u003E\u003Cp\u003E            holder.itemView.setTag(position);\u003C\u002Fp\u003E\u003Cp\u003E        } else if (holder instanceof FootViewHolder) {\u003C\u002Fp\u003E\u003Cp\u003E            FootViewHolder footViewHolder = (FootViewHolder) holder;\u003C\u002Fp\u003E\u003Cp\u003E            switch (load_more_status) {\u003C\u002Fp\u003E\u003Cp\u003E                case PULLUP_LOAD_MORE:\u003C\u002Fp\u003E\u003Cp\u003E                    footViewHolder.foot_view_item_tv.setText(\"上拉加载更多...\");\u003C\u002Fp\u003E\u003Cp\u003E                    break;\u003C\u002Fp\u003E\u003Cp\u003E                case LOADING_MORE:\u003C\u002Fp\u003E\u003Cp\u003E                    footViewHolder.foot_view_item_tv.setText(\"正在加载更多数据...\");\u003C\u002Fp\u003E\u003Cp\u003E                    break;\u003C\u002Fp\u003E\u003Cp\u003E            }\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F**\u003C\u002Fp\u003E\u003Cp\u003E     * 进行判断是普通Item视图还是FootView视图\u003C\u002Fp\u003E\u003Cp\u003E     *\u003C\u002Fp\u003E\u003Cp\u003E     * @param position\u003C\u002Fp\u003E\u003Cp\u003E     * @return\u003C\u002Fp\u003E\u003Cp\u003E     *\u002F\u003C\u002Fp\u003E\u003Cp\u003E    @Override\u003C\u002Fp\u003E\u003Cp\u003E    public int getItemViewType(int position) {\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002F 最后一个item设置为footerView\u003C\u002Fp\u003E\u003Cp\u003E        if (position + 1 == getItemCount()) {\u003C\u002Fp\u003E\u003Cp\u003E            return TYPE_FOOTER;\u003C\u002Fp\u003E\u003Cp\u003E        } else {\u003C\u002Fp\u003E\u003Cp\u003E            return TYPE_ITEM;\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    @Override\u003C\u002Fp\u003E\u003Cp\u003E    public int getItemCount() {\u003C\u002Fp\u003E\u003Cp\u003E        return mTitles.size() + 1;\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F\u002F自定义的ViewHolder，持有每个Item的的所有界面元素\u003C\u002Fp\u003E\u003Cp\u003E    public static class ItemViewHolder extends RecyclerView.ViewHolder {\u003C\u002Fp\u003E\u003Cp\u003E        public TextView item_tv;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E        public ItemViewHolder(View view) {\u003C\u002Fp\u003E\u003Cp\u003E            super(view);\u003C\u002Fp\u003E\u003Cp\u003E            item_tv = (TextView) view.findViewById(R.id.item_tv);\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F**\u003C\u002Fp\u003E\u003Cp\u003E     * 底部FootView布局\u003C\u002Fp\u003E\u003Cp\u003E     *\u002F\u003C\u002Fp\u003E\u003Cp\u003E    public static class FootViewHolder extends RecyclerView.ViewHolder {\u003C\u002Fp\u003E\u003Cp\u003E        private TextView foot_view_item_tv;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E        public FootViewHolder(View view) {\u003C\u002Fp\u003E\u003Cp\u003E            super(view);\u003C\u002Fp\u003E\u003Cp\u003E            foot_view_item_tv = (TextView) view.findViewById(R.id.foot_view_item_tv);\u003C\u002Fp\u003E\u003Cp\u003E        }\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F\u002F添加数据\u003C\u002Fp\u003E\u003Cp\u003E    public void addItem(List&amp;lt;String&amp;gt; newDatas) {\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002FmTitles.add(position, data);\u003C\u002Fp\u003E\u003Cp\u003E        \u002F\u002FnotifyItemInserted(position);\u003C\u002Fp\u003E\u003Cp\u003E        newDatas.addAll(mTitles);\u003C\u002Fp\u003E\u003Cp\u003E        mTitles.removeAll(mTitles);\u003C\u002Fp\u003E\u003Cp\u003E        mTitles.addAll(newDatas);\u003C\u002Fp\u003E\u003Cp\u003E        notifyDataSetChanged();\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    public void addMoreItem(List&amp;lt;String&amp;gt; newDatas, int status) {\u003C\u002Fp\u003E\u003Cp\u003E        mTitles.addAll(newDatas);\u003C\u002Fp\u003E\u003Cp\u003E        changeMoreStatus(status);\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    \u002F**\u003C\u002Fp\u003E\u003Cp\u003E     * \u002F\u002F上拉加载更多\u003C\u002Fp\u003E\u003Cp\u003E     * PULLUP_LOAD_MORE=0;\u003C\u002Fp\u003E\u003Cp\u003E     * \u002F\u002F正在加载中\u003C\u002Fp\u003E\u003Cp\u003E     * LOADING_MORE=1;\u003C\u002Fp\u003E\u003Cp\u003E     * \u002F\u002F加载完成已经没有更多数据了\u003C\u002Fp\u003E\u003Cp\u003E     * NO_MORE_DATA=2;\u003C\u002Fp\u003E\u003Cp\u003E     *\u003C\u002Fp\u003E\u003Cp\u003E     * @param status\u003C\u002Fp\u003E\u003Cp\u003E     *\u002F\u003C\u002Fp\u003E\u003Cp\u003E    public void changeMoreStatus(int status) {\u003C\u002Fp\u003E\u003Cp\u003E        load_more_status = status;\u003C\u002Fp\u003E\u003Cp\u003E        notifyDataSetChanged();\u003C\u002Fp\u003E\u003Cp\u003E    }\u003C\u002Fp\u003E\u003Cp\u003E}\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E3。MainRecyclerviewAdapter。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E主要是一个简单的系统的RecyclerView的实现效果，我个人在里面定义20条循环的同样的数据。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E4。文件名称：DividerItemDecoration是一个添加分割线的工具类。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u002F**********************************************************\u003C\u002Fp\u003E\u003Cp\u003E * @文件名称：DividerItemDecoration\u003C\u002Fp\u003E\u003Cp\u003E * @文件作者：孙顺涛\u003C\u002Fp\u003E\u003Cp\u003E * @Email：staryumou@163.com邮箱已改qyddai@gmail.com\u003C\u002Fp\u003E\u003Cp\u003E * @创建时间：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E * @文件描述：Recyclerview的分割线设置，系统默认的效果。 &amp;lt;!-- Application theme. --&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * 采用下面这种方式可以制定分割线。\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;style name=\"AppTheme\" parent=\"AppBaseTheme\"&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;item name=\"android:listDivider\"&amp;gt;@drawable\u002Fdivider_bg&amp;lt;\u002Fitem&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;\u002Fstyle&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * \u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=http%3A\u002F\u002Fschemas.android.com\u002Fapk\u002Fres\u002Fandroid\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E\u003Cspan class=\"invisible\"\u003Ehttp:\u002F\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"visible\"\u003Eschemas.android.com\u002Fapk\u003C\u002Fspan\u003E\u003Cspan class=\"invisible\"\u003E\u002Fres\u002Fandroid\u003C\u002Fspan\u003E\u003Cspan class=\"ellipsis\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\"\u003C\u002Fp\u003E\u003Cp\u003E * android:shape=\"rectangle\" &amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;p&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;gradient\u003C\u002Fp\u003E\u003Cp\u003E * android:centerColor=\"#ff00ff00\"\u003C\u002Fp\u003E\u003Cp\u003E * android:endColor=\"#ff0000ff\"\u003C\u002Fp\u003E\u003Cp\u003E * android:startColor=\"#ffff0000\"\u003C\u002Fp\u003E\u003Cp\u003E * android:type=\"linear\" \u002F&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;size android:height=\"4dp\"\u002F&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;p&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * &amp;lt;\u002Fshape&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E * @修改历史：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E **********************************************************\u002F\u003C\u002Fp\u003E\u003Cp\u003E 5。DRecycleViewDivider也是一个添加分割线的工具类。是在网上找的，但是（我在使用的时候发现有点问题）\u003C\u002Fp\u003E\u003Cp\u003E \u002F**********************************************************\u003C\u002Fp\u003E\u003Cp\u003E * @文件名称：DRecycleViewDivider\u003C\u002Fp\u003E\u003Cp\u003E * @文件作者：孙顺涛\u003C\u002Fp\u003E\u003Cp\u003E * @Email：staryumou@163.com邮箱已改qyddai@gmail.com\u003C\u002Fp\u003E\u003Cp\u003E * @创建时间：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E * @文件描述：自定义recycleView的万能分割线。\u003C\u002Fp\u003E\u003Cp\u003E * @修改历史：2016\u002F9\u002F8\u003C\u002Fp\u003E\u003Cp\u003E **********************************************************\u002F\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## 重要知识点（总结，思考）。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E1）在使用RecyclerView时，你会发现RecyclerView并没有支持divider这样的属性。那么怎么办，你可以给Item的布局去设置margin，当然了这种方式不够优雅，我们文章开始说了，我们可以自由的去定制它，当然我们的分割线也是可以定制的。\u003C\u002Fp\u003E\u003Cp\u003E在上面分割线的代码注释里面已经写出来了，添加这样的代码即可。\u003C\u002Fp\u003E\u003Cp\u003EmRecyclerView.addItemDecoration() \u003C\u002Fp\u003E\u003Cp\u003E该方法的参数为RecyclerView.ItemDecoration，该类为抽象类，google官方目前并没有提供默认的实现类（我觉得最好能提供几个）。 \u003C\u002Fp\u003E\u003Cp\u003E该类的源码：\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003Epublic static abstract class ItemDecoration {\u003C\u002Fp\u003E\u003Cp\u003Epublic void onDraw(Canvas c, RecyclerView parent, State state) {\u003C\u002Fp\u003E\u003Cp\u003E            onDraw(c, parent);\u003C\u002Fp\u003E\u003Cp\u003E }\u003C\u002Fp\u003E\u003Cp\u003Epublic void onDrawOver(Canvas c, RecyclerView parent, State state) {\u003C\u002Fp\u003E\u003Cp\u003E            onDrawOver(c, parent);\u003C\u002Fp\u003E\u003Cp\u003E }\u003C\u002Fp\u003E\u003Cp\u003Epublic void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) {\u003C\u002Fp\u003E\u003Cp\u003E            getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),\u003C\u002Fp\u003E\u003Cp\u003E                    parent);\u003C\u002Fp\u003E\u003Cp\u003E}\u003C\u002Fp\u003E\u003Cp\u003E@eprecated\u003C\u002Fp\u003E\u003Cp\u003Epublic void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {\u003C\u002Fp\u003E\u003Cp\u003E            outRect.set(0, 0, 0, 0);\u003C\u002Fp\u003E\u003Cp\u003E }\u003C\u002Fp\u003E\u003Cp\u003E 当我们调用mRecyclerView.addItemDecoration()方法添加decoration的时候，RecyclerView在绘制的时候，去会绘制decorator，即调用该类的onDraw和onDrawOver方法，\u003C\u002Fp\u003E\u003Cp\u003EonDraw方法先于drawChildren\u003C\u002Fp\u003E\u003Cp\u003EonDrawOver在drawChildren之后，一般我们选择复写其中一个即可。\u003C\u002Fp\u003E\u003Cp\u003EgetItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator。\u003C\u002Fp\u003E\u003Cp\u003E接下来我们看一个RecyclerView.ItemDecoration的实现类，该类很好的实现了RecyclerView添加分割线（当使用LayoutManager为LinearLayoutManager时）。 \u003C\u002Fp\u003E\u003Cp\u003E也就是上面第四点的那个类。该类参考至：鸿洋-- \u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=http%3A\u002F\u002Fblog.csdn.net\u002Flmj623565791\u002Farticle\u002Fdetails\u002F38173061\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003EAndroid 自定义RecyclerView 实现真正的Gallery效果\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E    &amp;lt;!-- Application theme. --&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E    &amp;lt;style name=\"AppTheme\" parent=\"AppBaseTheme\"&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E      &amp;lt;item name=\"android:listDivider\"&amp;gt;@drawable\u002Fdivider_bg&amp;lt;\u002Fitem&amp;gt;  \u003C\u002Fp\u003E\u003Cp\u003E    &amp;lt;\u002Fstyle&amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\t&amp;lt;?xml version=\"1.0\" encoding=\"utf-8\"?&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=http%3A\u002F\u002Fschemas.android.com\u002Fapk\u002Fres\u002Fandroid\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E\u003Cspan class=\"invisible\"\u003Ehttp:\u002F\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"visible\"\u003Eschemas.android.com\u002Fapk\u003C\u002Fspan\u003E\u003Cspan class=\"invisible\"\u003E\u002Fres\u002Fandroid\u003C\u002Fspan\u003E\u003Cspan class=\"ellipsis\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\"\u003C\u002Fp\u003E\u003Cp\u003E    android:shape=\"rectangle\" &amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    &amp;lt;gradient\u003C\u002Fp\u003E\u003Cp\u003E        android:centerColor=\"#ff00ff00\"\u003C\u002Fp\u003E\u003Cp\u003E        android:endColor=\"#ff0000ff\"\u003C\u002Fp\u003E\u003Cp\u003E        android:startColor=\"#ffff0000\"\u003C\u002Fp\u003E\u003Cp\u003E        android:type=\"linear\" \u002F&amp;gt;\u003C\u002Fp\u003E\u003Cp\u003E    &amp;lt;size android:height=\"4dp\"\u002F&amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E    &amp;lt;\u002Fshape&amp;gt;\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E## 内容参考。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E这里RecyclerView的adaper封装是借用鸿翔的 ： \u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fgithub.com\u002FhongyangAndroid\u002FbaseAdapter\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003EGitHub - hongyangAndroid\u002FbaseAdapter: Android 万能的Adapter for ListView,RecyclerView,GridView等，支持多种Item类型的情况。\u003C\u002Fa\u003E 这个封装的很好的\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E他又是引用的这个开源项目的FastDev4Android :  \u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fgithub.com\u002Fjiangqqlmj\u002FFastDev4Android\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003EGitHub - jiangqqlmj\u002FFastDev4Android: 本项目是Android快速开发框架，采用AndroidStudio进行开发。 预想集成工具包,采用MVP开发模式,EventBus数据分发,沉浸式状态栏,ORM,网络请求(HTTPClint,Volley,OkHttps),数据解析,依赖注入(AndroidAnnotations),xutils,图片异步加载，二维码扫描等等，后续会进行逐步添加\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E这里刷新的框架用的是 \u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fgithub.com\u002FOrangeGangsters\u002FSwipyRefreshLayout\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003EGitHub - OrangeGangsters\u002FSwipyRefreshLayout: A SwipeRefreshLayout extension that allows to swipe in both direction\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E个人觉得无论做什么思想很重要，没有思路你怎么都不会造好轮子。\u003C\u002Fp\u003E\u003Cp\u003E## 联系作者。\u003C\u002Fp\u003E\u003Cp\u003EAthor：sunshuntao（qydq）。\u003C\u002Fp\u003E\u003Cp\u003EEmail：qyddai@gmail.com。\u003C\u002Fp\u003E\u003Cp\u003E知乎地址：\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fqyddai\" class=\"internal\"\u003EAndroid开发 - 知乎专栏\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003EEnd\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003EGithub上面都是开源项目，欢迎大家下载我的项目或者有问题的同学可以发送邮件给我，如果收到邮件我会第一次时间回复处理。\u003C\u002Fp\u003E\u003Cp\u003E项目地址:\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fgithub.com\u002Fqydq\u002Faw-RecyclerView\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E\u003Cspan class=\"invisible\"\u003Ehttps:\u002F\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"visible\"\u003Egithub.com\u002Fqydq\u002Faw-Recy\u003C\u002Fspan\u003E\u003Cspan class=\"invisible\"\u003EclerView\u003C\u002Fspan\u003E\u003Cspan class=\"ellipsis\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":22362839,"publishedTime":"2016-09-08T14:28:49+08:00","url":"\u002Fp\u002F22362839","title":"RecyclerView解析之下拉刷新与上拉加载SwipeRefreshLayout（含分割线工具类）","summary":"标题的图片盗用google+ 上面 Ankita Narayan美女的； 附上地址她的主页，外国人应该不太用知乎这种来交流吧。 \u003Ca href=\"https:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fplus.google.com\u002F100907098925781574510\" class=\"\" data-editable=\"true\" data-title=\"https:\u002F\u002Fplus.google.com\u002F100907098925781574510\"\u003Ehttps:\u002F\u002Fplus.google.com\u002F100907098925781574510\u003C\u002Fa\u003E\u003Cb\u003EBeging\u003C\u002Fb\u003E# aw-RecyclerView 先看一下效果图吧 This is aw project about how to setting backgroun…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":3},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https:\u002F\u002Fpic4.zhimg.com\u002F50\u002Fb7153a2776958d2529f8429401e533ad_xl.jpg","links":{"comments":"\u002Fapi\u002Fposts\u002F22424181\u002Fcomments"},"topics":[{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19629084","id":"19629084","name":"Maven"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19596718","id":"19596718","name":"Eclipse"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Ftopic\u002F19551557","id":"19551557","name":"设计"}],"adminClosedComment":false,"href":"\u002Fapi\u002Fposts\u002F22424181","excerptTitle":"","author":{"bio":"即时通讯，软件设计与开发者，物联网，移动互联网，AIVRVI兴趣者","isFollowing":false,"hash":"071d1fea34ab3dc8850d9aa78d844fdb","uid":664439680704057300,"isOrg":false,"slug":"qydq","isFollowed":false,"description":"专注于物联网领域，世界的通信标准从今开始改变，手机也可以是路由器，成功于视频直播,标准并不一定是Http\u002Fs，也可以是Bluetooth。","name":"Bgwan","profileUrl":"https:\u002F\u002Fwww.zhihu.com\u002Fpeople\u002Fqydq","avatar":{"id":"464372bfcc3e304100f3cad266280fd5","template":"https:\u002F\u002Fpic2.zhimg.com\u002F{id}_{size}.jpg"},"isOrgWhiteList":false,"isBanned":false},"column":{"slug":"qyddai","name":"Android开发"},"content":"maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。\u003Cbr\u003Emaven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性\u003Cbr\u003E利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。\u003Cp\u003E\u003Cb\u003EBegin\u003C\u002Fb\u003E\u003C\u002Fp\u003E而大家都知道android项目是如何发布到Jcenter代码库中。Jcenter是一个maven的标准代码库，向我们平时通过compile \u003Cbr\u003E引用的library库其实基本都是从Jcenter库中下载。当然这次我们来配置eclipse的maven管理。用maven的仓库在开发中能够事半功倍。\u003Cp\u003E第一步：首先在apache的官方下载maven的zip \u003C\u002Fp\u003E\u003Ca href=\"http:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fprojects.apache.org\u002F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003Eeclipse-maven-plugin.zip ( for eclipse helios or higher ) \u003C\u002Fa\u003E\u003Cp\u003E解压缩出来，随便放置到一个盘中。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002F1383151b8644a06aeecef148c9103e38_b.jpg\" data-rawwidth=\"560\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb\" width=\"560\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002F1383151b8644a06aeecef148c9103e38_r.jpg\"\u003E\u003C\u002Ffigure\u003E目录路径最好不要含有中文或空格。以下用 %maven-plugin% 表示插件解压缩的根目录。如这里的 E:\u002Fsetup\u002Fdev\u002Feclipse\u002Fplugins\u002Fmaven。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cbr\u003E第二步：配置环境变量。\u003Cbr\u003E\u003Cbr\u003Ea. MAVEN_HOME:D:\\Software_IDE\\apache-maven-3.0.4\u003Cbr\u003E\u003Cbr\u003Eb.PATH:%MAVEN_HOME%\\bin;\u003Cp\u003E配置好了验证一下，因为之前有配置过，如下图。\u003C\u002Fp\u003E\u003Cp\u003Ecmd 输入maven -version\u003C\u002Fp\u003E\u003Cp\u003E\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002F42400223da2236757e7bc5b3cf7f21c8_b.jpg\" data-rawwidth=\"701\" data-rawheight=\"189\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002F42400223da2236757e7bc5b3cf7f21c8_r.jpg\"\u003E\u003C\u002Ffigure\u003E第三步：修改maven仓库的路径。\u003C\u002Fp\u003E\u003Cp\u003E在D盘，新建文件夹，如图，\u003C\u002Fp\u003E\u003Cp\u003E\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002F6280a80457f97cadb00f432e00a1cf1c_b.jpg\" data-rawwidth=\"318\" data-rawheight=\"116\" class=\"content_image\" width=\"318\"\u003E\u003C\u002Ffigure\u003Esettings.xml中输入如下内容即可。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E&amp;lt;span style=\"font-family:KaiTi_GB2312;font-size:18px;\"&amp;gt;&amp;lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&amp;gt;\nhttp:\u002F\u002Fmaven.apache.org\u002FSETTINGS\u002F1.0.0\" \n          xmlns:xsi=\"http:\u002F\u002Fwww.w3.org\u002F2001\u002FXMLSchema-instance\" \n          xsi:schemaLocation=\"http:\u002F\u002Fmaven.apache.org\u002FSETTINGS\u002F1.0.0 http:\u002F\u002Fmaven.apache.org\u002Fxsd\u002Fsettings-1.0.0.xsd\"&amp;gt;\n\t\n\t&amp;lt;pluginGroups \u002F&amp;gt;\n\t&amp;lt;proxies \u002F&amp;gt;\n\t&amp;lt;servers \u002F&amp;gt;\n\t&amp;lt;mirrors \u002F&amp;gt;\n\t&amp;lt;localRepository&amp;gt;D:\u002Fm2\u002Frepository&amp;lt;\u002FlocalRepository&amp;gt;\n&amp;lt;\u002Fsettings&amp;gt;&amp;lt;\u002Fspan&amp;gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E然后再D:\\ide\\apache-maven-3.3.9\\conf盘中找到Settings.xml修改默认的配置路径为你刚刚新建文件夹的路径，\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E   &amp;lt;--| The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}\u002F.m2\u002Frepository---&amp;gt;\n\n  &amp;lt;localRepository&amp;gt;D:\\Users\\repository&amp;lt;\u002FlocalRepository&amp;gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E第四步：\u003C\u002Fp\u003E\u003Cp\u003E配置eclipse中maven，打开eclipse ，windows --&amp;gt;preference--&amp;gt;maven\u003C\u002Fp\u003E\u003Cp\u003E找到instanlation ，点击add ，添加你刚刚的maven的压缩文件地址。\u003C\u002Fp\u003E\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fd4755d2f30de5b15c9cd40b5cc378491_b.jpg\" data-rawwidth=\"619\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb\" width=\"619\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fd4755d2f30de5b15c9cd40b5cc378491_r.jpg\"\u003E\u003C\u002Ffigure\u003E\u003Cbr\u003E\u003Cp\u003E在User Settings中，选择你刚刚自己修改的maven仓库的地址即可\u003C\u002Fp\u003E\u003Cp\u003E即选择D:\\Users\\repository路径下的settings.xml文件。\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cp\u003E第五步：最后，大功告成，你可以新建一个项目，new project \u002F选择other ,选择new maven project ,\u003C\u002Fp\u003E\u003Cp\u003Enext next , \u003C\u002Fp\u003E\u003Cp\u003E验证结果。\u003C\u002Fp\u003E\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002F2a7451a7a0d4b05ce5556de652b68037_b.jpg\" data-rawwidth=\"844\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002F2a7451a7a0d4b05ce5556de652b68037_r.jpg\"\u003E\u003C\u002Ffigure\u003E\u003Cbr\u003E\u003Cp\u003E\u003Cb\u003EEnd \u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\u003Cp\u003E\u003Cb\u003E作者：sunshuntao ,2016.09月记。\u003C\u002Fb\u003E\u003C\u002Fp\u003E","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":22424181,"publishedTime":"2016-09-13T09:43:23+08:00","url":"\u002Fp\u002F22424181","title":"eclipse快速配置Maven plugin 安装","summary":"maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。 maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性 利用maven自身及其插…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"annotationDetail":null,"commentsCount":0,"likesCount":1,"FULLINFO":true}},"User":{"qydq":{"isFollowed":false,"name":"Bgwan","headline":"专注于物联网领域，世界的通信标准从今开始改变，手机也可以是路由器，成功于视频直播,标准并不一定是Http\u002Fs，也可以是Bluetooth。","avatarUrl":"https:\u002F\u002Fpic2.zhimg.com\u002F464372bfcc3e304100f3cad266280fd5_s.jpg","isFollowing":false,"type":"people","slug":"qydq","bio":"即时通讯，软件设计与开发者，物联网，移动互联网，AIVRVI兴趣者","hash":"071d1fea34ab3dc8850d9aa78d844fdb","uid":664439680704057300,"isOrg":false,"description":"专注于物联网领域，世界的通信标准从今开始改变，手机也可以是路由器，成功于视频直播,标准并不一定是Http\u002Fs，也可以是Bluetooth。","badge":{"identity":null,"bestAnswerer":null},"profileUrl":"https:\u002F\u002Fwww.zhihu.com\u002Fpeople\u002Fqydq","avatar":{"id":"464372bfcc3e304100f3cad266280fd5","template":"https:\u002F\u002Fpic2.zhimg.com\u002F{id}_{size}.jpg"},"isOrgWhiteList":false,"isBanned":false}},"Comment":{},"favlists":{}},"me":{},"global":{"experimentFeatures":{"ge3":"ge3_9","ge2":"ge2_1","growthSearch":"s2","nwebQAGrowth":"experiment","qawebRelatedReadingsContentControl":"close","liveStore":"ls_a2_b1_c2_f2","qawebThumbnailAbtest":"new","nwebSearch":"nweb_search_heifetz","rt":"y","showVideoUploadAttention":"true","isOffice":"false","enableTtsPlay":"post","editorVideomakerEntrance":"e","enableVoteDownReasonMenu":"enable","newLiveFeedMediacard":"new","newMobileAppHeader":"true","androidPassThroughPush":"all","hybridZhmoreVideo":"no","nwebGrowthPeople":"default","nwebSearchSuggest":"default","qrcodeLogin":"qrcode","seE":"0","androidDbFollowRecommendHide":"open","isf8":"1","isShowUnicomFreeEntry":"unicom_free_entry_off","newMobileColumnAppheader":"new_header","feedHybridTopicRecomButtonIcon":"yes","androidDbRecommendAction":"open","zcmLighting":"zcm","androidDbFeedHashTagStyle":"button","appStoreRateDialog":"close","default":"None","isNewNotiPanel":"no","wechatShareModal":"wechat_share_modal_show","growthBanner":"default","androidProfilePanel":"panel_b"}},"columns":{"next":{},"qyddai":{"following":false,"canManage":false,"href":"\u002Fapi\u002Fcolumns\u002Fqyddai","name":"Android开发","creator":{"slug":"qydq"},"url":"\u002Fqyddai","slug":"qyddai","avatar":{"id":"v2-28a7c692cda8c760ec9a242440d652ac","template":"https:\u002F\u002Fpic1.zhimg.com\u002F{id}_{size}.jpg"}}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldSetPoster":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"edition":{"baidu":false,"yidianzixun":false,"qqnews":false},"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false,"userAgent":{"ua":"Mozilla\u002F5.0 (Windows NT 10.0; WOW64) AppleWebKit\u002F537.36 (KHTML, like Gecko) Chrome\u002F55.0.2883.87 Safari\u002F537.36","browser":{"name":"Chrome","version":"55.0.2883.87","major":"55"},"engine":{"version":"537.36","name":"WebKit"},"os":{"name":"Windows","version":"10"},"device":{},"cpu":{"architecture":"amd64"}}},"message":{"newCount":0},"pushNotification":{"newCount":0}}</textarea><script src="./android （MD）v7.widget.SearchView的使用解析。_files/common.62693697de4a01275e2d.js"></script><script src="./android （MD）v7.widget.SearchView的使用解析。_files/app.735f30554cc42d18d60e.js"></script><script src="./android （MD）v7.widget.SearchView的使用解析。_files/raven.ea0a3fa31a2e3ea2cec6.js" async="" defer=""></script><div><div data-reactroot=""><div class="Editable-languageSuggestions" style="left: -1179px; top: -999px;"><div><div class="Popover"><div class="Editable-languageSuggestionsInput Input-wrapper"><input value="" autocomplete="off" role="combobox" aria-expanded="false" aria-autocomplete="list" aria-activedescendant="AutoComplet-92478-60603-0" id="Popover-92478-8018-toggle" aria-haspopup="true" aria-owns="Popover-92478-8018-content" class="Input" placeholder="选择语言"><div class="Input-after"><svg class="Zi Zi--Select" fill="#afbdcf" viewBox="0 0 24 24" width="24" height="24"><path d="M12 16.183l2.716-2.966a.757.757 0 0 1 1.064.001.738.738 0 0 1 0 1.052l-3.247 3.512a.758.758 0 0 1-1.064 0L8.22 14.27a.738.738 0 0 1 0-1.052.758.758 0 0 1 1.063 0L12 16.183zm0-9.365L9.284 9.782a.758.758 0 0 1-1.064 0 .738.738 0 0 1 0-1.052l3.248-3.512a.758.758 0 0 1 1.065 0L15.78 8.73a.738.738 0 0 1 0 1.052.757.757 0 0 1-1.063.001L12 6.818z" fill-rule="evenodd"></path></svg></div></div><!-- react-empty: 10 --></div></div></div></div></div></body></html>